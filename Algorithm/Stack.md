# Stack

## 스택

* 자료를 쌓아 올린 형태의 자료구조

* 선형 구조

  * 자료 간의 관계가 1대1의 관계.

    (cf. 비선형구조: 자료 간의 관계가 1대N의 관계를 갖는다. ex. 트리)

- 스택에 자료를 삽입하거나 꺼낼 수 있다.
- **후입선출**(LIFO. Last In First Out): 마지막에 삽입한(올려놓은) 자료를 가장 먼저 꺼낸다

### 스택의 구현

* 스택을 프로그램에서 구현하기 위해 필요한 자료구조와 연산

  * 자료구조: 자료를 선형으로 저장할 저장소

    * 배열을 사용할 수 있다.
    * 저장소 자체를 스택이라고 부르기도 한다
    * 스택에서 마지막 저장된 원소의 위치를 top이라 부른다.
      * stack pointer: 스택의 맨 꼭대기를 가리킨다.

  * 연산

    * push: 삽입. 저장소에 자료를 저장한다
    * pop: 삭제. 저장소에서 자료를 꺼낸다.
    * isEmpty: 스택이 공백인지 아닌지를 확인하는 연산
    * peek: 스택의 top에 있는 item(원소)을 반환(꺼내지는 않고 확인만)하는 연산

  * 스택의 삽입/삭제 과정

    * 빈 스택에 원소 A, B, C를 차례로 삽입 후 한번 삭제하는 연산 과정
      * 공백스택일 때(top은 밑바닥을 가리킴) push A한다.
        * top을 1 증가시키고 top이 가리키는 곳에 실제 A를 집어넣는다
      * push B
      * pop B
        * top이 가리키고 있는 것을 꺼낸다. 그 후 top을 감소시킨다.
        * 꺼내고 굳이 지울 필요 없다.
      * push C
        * top을 증가시키고 D를 집어넣는다.(덮어씌워짐)

  * 스택의 push 알고리즘

    * append 메소드를 통해 리스트의 마지막에 데이터를 삽입

    ```python
    def push(item):
        s.append(item)
        
    #append 없이 구현하기
    def push(item, size):
        global top
        top+= 1
        if top == size:
            print('overflow')	#디버깅용
        else:
            stack[top] = item
    size = 10
    stack = [0] * size
    top = -1
    push(10, size)
    top += 1					#push(20)
    stack[top] = 20
    ```

  * 스택의 pop 알고리즘

    ```python
    def pop():
        if len(s) == 0:
            #underflow
            return
        else:
            return s.pop(-1)
        
    #pop을 쓰지 않고 구현하기
    def pop():
        global top
        if top == -1:
            #underflow
            return 0
        else:
            top -= 1
            return stack[top+1]
    print(pop())
    while top >= 0:	#pop()
        n = stack[top]
        top -= 1
    ```

  +) append와 pop은 시간이 오래걸리는 방법이다.

- 스택 구현 고려 사항
  - 1차원 배열을 사용하여 구현할 경우 구현이 용이하다는 장점이 있지만 스택의 크기를 변경하기가 어렵다는 단점이있다. => 문제를 풀때에는 필요한 만큼 크게 만들어서 사용하면 된다.
  - 이를 해결하기 위한 방법
    - 저장소를 동적으로 할당하여 스택 구현(=동적 연결리스트를 이용하여 구현)
      - 구현이 복잡하지만 메모리를 효율적으로 사용
- 스택 응용
  - 괄호 검사
    - 여는 괄호를 스택에 쌓고, 닫는 괄호를 만났을 때 pop으로 뺀다.
      - 여러 종류의 괄호가 섞여있는 경우,  오른쪽 괄호와 짝이 맞는지 검사
    - 괄호 수식이 끝났는데 스택에 괄호가 남아있으면 오류
    - 괄호 수식이 남았는데 스택에 괄호가 남아있지 않아도 오류
  - Function call
    - 프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리
      - 가장 마지막에 호출된 함수가 가장 먼저 실행을  완료하고 복귀하는 후입선출 구조이므로, 후입선출 구조의 스택을 이용하여 수행 순서 관리
      - 함수의 실행이 끝나면 시스템 스택의 top원소를 삭제하면서 프레임에 저장되어 있던 복귀주소를 확인하고 복귀



## 재귀호출

- 자기 자신을 호출하여 순환 수행되는 것

- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출 방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성 가능.

- 마지막에 구한 하위 값을 이욯아여 상위 값을 구하는 작업 반복

  ex1. factorial

  ​		 	fact(4) = 4 * fact(3) = 4 * 3 * fact(2) = 4 * 3 * 2 * fact(1) = 4 * 3 * 2 * 1

  ex2.  피보나치 수열(0과 1로 시작하고 이전의 두 수 합을 다음 항으로 하는 수열.)

  ```python
  def fibo(n):
      if n < 2:
          return n
      else:
          return fibo(n-1) + fibo(n-2)
  ```

  +. 재귀함수의 기본형: f(i,N). i는 현재 위치, N은 목표(어디까지 갈껀지)

  ​	팩토리얼이나 피보나치의 경우 감소하며 0이나 1에서 멈추기 때문에 하나의 파라미터만 있어도 된다.

- Memoization

  - 피보나치 수를 재귀함수로 구현하면 엄청난 중복 호출이 존재한다는 문제점이 존재한다. 이를 해결하기 위한 기술
  - 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술. 
  - 동적 계획법의 핵심이 되는 기술

  ```python
  #memoization을 활용해 피보나치 수를 구해보자.
  def fibo(n):
      global memo
      if n>=2 and len(memo) <= n:
          memo.append(fibo(n-1)+fibo(n-2))
  memo = [0, 1] 
  #다른 방법
  def fibo(n):
      global memo
      if n>=2 and memo[n] == 0:
          memo.append(fibo(n-1)+fibo(n-2))
  memo = [0] * (n+1)
  memo[0] = 0
  memo[1] = 1 
  ```

  

* DP(Dynamic Programming) - 동적 계획 알고리즘

  * 그리디 알고리즘과 같이 **최적화 문제**를 해결하는 알고리즘

  * 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘

  * ex. 피보나치 풀어나가는  법 => 반복 구조로 만들면 함수 호출 시간이 들지 않는다.

    1. 문제를 부분 문제로 분할한다.
       - fibo(n) = fibo(n-1)+fibo(n-2)
       - fibo(n-1) = fibo(n-2) + fibo(n-3) ...
    2. 부분 문제로 나누는 일을 끝냈으면 가장 작은 부분 문제부터 해를 구한다
    3. 그  결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해를 구한다.

    ```python
    #피보나치 DP 적용1
    fibo = [0] * (N+1)
    fibo[0] = 0
    fibo[1] = 1
    for i in range(2, N+1):
        fibo[i] = fibo[i-1] + fibo[i-2]
    #피보나치 DP 적용2
    def fibo(n):
        f = [0, 1]
        for i in range(2, n+1):
            f.append(f[i-1]+f[i-2])
        return f[n]
    ```

  - memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 보다 효율적이다. 
    - 왜냐하면 재귀적 구조는 내부에 시스템 호출 스택을 사용하는 오버헤드가 발생하기 때문이다.

- DFS
  - 비선형구조인 그래프  구조는 표현된 모든 자료를 빠짐없이 검색하는 것이 중요
  - 방법
    - 깊이 우선 탐색(Depth First Search, DFS)

      - 한 방향으로 갈 수 있는 경로가 있는 곳까지 <u>깊이 탐색해가다가 더 이상 갈 곳이 없게 되면,</u> **가장 마지막에 만났던 갈림길 간선이 있는 정점**으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법

      - 재귀나 반복(스택)을 활용해 구현

        - 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야하므로 후입선출 구조의 스택 사용

      - 과정

        1. 시작 정점 v를 결정하여 방문한다
        2. 정점 v에 인접한 정점 중에서
           1. 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다.(정점 여러개 있으면 규칙(ex.오름차순)에 따라 탐색) 그리고 w를 v로 하여 다시 2)를 반복한다
           2. 방문하지 않은 정점이 없으면, 탐색의 방향을 바꾸기 위해서 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2)를 반복한다
           3. 스택이 공백이 될 때까지 2)를 반복한다.

        ```python
        #그래프의 정보:  '1과 2가 인접이야' '1과 3이 인접이야'와 같이 인접 정보를 주면, 두개를 먼저 꺼내서 인접 행렬(2차원-보통 행이 출발, 열이 도착)로 표시해둔다. 
        #정점 A를 시작으로 DFS 우선 탐색. => 방문하면 visited 1로 표기. 이동할 때 stack에 A 넣어줌
        #B에 연결된 애 A,D,E. A는 이미 방문했으므로(visited[0]=1) B stack에 넣어두고, D로 이동해서 visited에 넣어준다. 이를 반복
        #더 이상 안갔던 인접정점이 없으므로 stack에서 pop을 한 후 그 곳으로 돌아간다. 없다면 계속 반복.
        #방문하지 않은 정점을 찾으면 방문하고 방문했다고 표시 남겨라
        #stack에서 계속 pop해서 방문하지 않은 곳 있나 확인한다.
        ```
      



- 계산기

  ```python
  N = int(input())
  infix = input()
  postfix = ''
  stack = [0] * N
  top = -1
  icp = {'+': 1, '*': 2}  # 연산자 우선순위
  for i in range(N):
      if '0' <= infix[i] <= '9':  # 피연산자인 경우
          postfix += infix[i]
      else:  # 연산자인 경우
          while top > -1 and icp[stack[top]] >= icp[infix[i]]:  # stack[top] 우선순위가 같거나 높으면  pop
              postfix += stack[top]
              top -= 1
          top += 1
          stack[top] = infix[i]
  while top > -1:
      postfix += stack[top]
      top -= 1
  print(postfix)
  ```

  

  - 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다.

  - 일반적인 방법

    1. 스택을 이용하여 중위표기법의 수식을 후위 표기법으로 변경한다

       - 중위표기법: 연산자를 피연산자의 가운데 표기하는 방법 ex. A+B

       - 후위 표기법: 연산자를 피연산자 뒤에 표기하는 방법 ex. AB+

       - 방법

         - 직접할 때: 수식의 각 연산자에 대해 우선순위에 따라 괄호를 사용하여 다시 표현. 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동시킨다. 괄호 제거.

           ex. A\*B-C/D => ( (A\*B)-(C/D) ) => ( (AB)\*-(CD)/ )- => AB\*-CD/ -

         - 스택을 활용한 변환 알고리즘

           1. 입력 받은 중위 표기식에서 토큰을 읽는다.

           2. 토큰이 피연산자: 토큰을 출력

           3. 토큰이 연산자(괄호 포함)

              | 토큰 | isp(in-stack priority)<br />스택 내에서의 우선순위 | icp(in-coming priority)<br />스택에 들어오기 전 우선순위 |
              | ---- | -------------------------------------------------- | -------------------------------------------------------- |
              | )    | -                                                  | -                                                        |
              | *, / | 2                                                  | 2                                                        |
              | +, - | 1                                                  | 1                                                        |
              | (    | 0                                                  | 3                                                        |

              1. 토큰이 스택의 top에 저장되어있는 연산자보다 우선순위(icp)가 높으면   stack에 push 
              2. 우선순위가 낮다면 스택 top의 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push 
              3. top에 연산자가 없다면 push

           4. 토큰이 ')'이면 스택 top에 '('가 나올 때까지 stack에 pop 연산 수행. pop한 연산자 출력. '(' 만나면 pop만 하고 출력하지는 않는다.

           5. 중위 표기식에 더 읽을 것이 없다면 중지. 더 읽을 것이 있다면 다시 반복

           6. 스택에 남아있는 연산자를 모두 pop하여 출력

              - 스택 밖의 왼쪽 괄호는 우선 순위가 가장 높으며 스택 안의 왼쪽 괄호는 우선 순위가 가장 낮다.
       
    2. 후위 표기법의 수식을 스택을 이용하여 계산한다.
    
       1. 피연산자를 만나면 스택에 push
       2. 연산자를 만나면 필요한만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push한다(처음에 pop한 애를 뒤로 둔다.)
       3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력한다.
       
          


- 백트래킹

  - 해를 찾는 도중에 막히면(=해가 아니면) 되돌아가서 다시 해를 찾아가는 기법

    - 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 감.(유망하다=어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 수 있다)

  - 과정

    1. 상태 공간 트리의 깊이 우선 검색을 실시
    2. 각 노드가 유망한지를 점검
    3. 만약 그 노드가 유망하지 않으면 그 노드의 부모 노드로 돌아가서 검색을 계속한다.

  - 최적화 문제와 결정 문제를 해결할 수 있다.

    - 결정문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes 혹은 no로 답하는 문제

      ex. 미로찾기/n-Queen/Map coloring/부분집합의 합 문제 등

      - 미로찾기

        ```python
        def checknode(v):	#node
            if promising(v):
                if there is a solution at v:
                    write the solution
                else:
                    for u in each child of v:
                        checknode(u)
        ```

        

      - 부분집합 구하기

        - powerset: 어떤 집합의 공집합과 자기자신을 포함하는 모든 부분집합. 집합의 원소 개수가 n일 때 부분집합의 개수는 2^n개
        - 과정
          - n개의 원소가 들어있는 집합의  2^n개 부분집합을 만들 때는 true 또는 false값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용(배열의 i번째 항목 = i번째 원소가 부분집합의 값인지 아닌지를 나타냄)

      - 순열 구하기

        - 집합{1,2,3}의 원소에 대해 각 부분집합에서의 포함 여부를 트리로 표현

          - 넣고 다음으로 쭉 가본 후 더 이상  결정할 수 없는게 없으면 백트래킹
          - A = [1,2,3]		bit = [1,1,1] => {1,2,3}        bit=[1,1,0]=>{1,2} 

          ```python
          def f(i,N,K):	#i:부분집합에 포함될지 결정할 원소의 인덱스 N: 전체 원소 개수 K:찾는 합
              if i==N:		#한 개의  부분집합 완성
                  s=0
                  for j in range(N):
                      if bit[j]:
                          s+=a[j]
                  if s==K:	#찾는 합이면
                      for j in range(N):
                          if bit[j]:
                              print(a[j], end='  ')
                          print()
                  else:
                      bit[i] = 1
                      f(i+1,N, K)
                      bit[i]=0
                      f(i+1, N, K)
                  return
                      
          a = [1,2,3,4,5,6,7,8]
          N = len(a)
          bit = [0] * N
          f(0,N, 10)
          ```

        - 자리를 바꿔서 순열을 만드는 방법 ex.[1,2,3]

          - P[0]결정
            - 1맨 처음에 1 유지 => 1인 자기 자신과 자리를 바꾼다
            - P[1]결정
              - 2자기 자신과 자리를 바꾼다
              - 6오른쪽에 있는 인덱스와 값을 교환한다 ... 
            - P[2]결정
              - 3자기 자신과 자리를 바꾼다
              - 5오른쪽에 바꿀 대상이 없으므로 리턴
            - 완성
              - 4더 바꿀 것 없으면 리턴
        
          ```python
          def f(i,N):
              if i==N:
                  print(p)
              else:
                  for j in range(i, N):
                      p[i], p[j] = p[j], p[i]
                      f(i+1, N)				#다음자리 결정하러 ㄱㄱ
                      p[i], p[j] = p[j], p[i]	#원상복구    
          p=[1,2,3]
        N=3
        f(0,N)
          ```
        
          
        
      - 원소들의 합으로 원하는 합을 만들 수 있는지
      
        ```python
        def f(i, N, s, t, rs):	#i-1원소까지 고려한 합 s, 찾으려는 합(목표값) t
            #남은 원소의 합을 다 더해도 찾는 값 T 미만인 경우 중단 
            if s==t:	#목표값을 찾으면
                for j in range(N):
                    if bit[j]:
                        print(a[j], end=' ')
                print()
            elif i==N:	#더이상 고려할 원소가 없으면
                return
            elif s>t:	#고려한 원소의 합 s가 이미 목표를 초과한 경우
                return
            elif s+rs<t:
                return
            else:		#남은 원소가 있고 s<t인 경우 
                bit[i]=i#어떤 원소들로 목표값을 도달했는지 알기 위해
                f(i+1, N, s+a[i],t,rs-a[i])
                bit[i]=0
                f(i+1, N, s, t)
            return
              
        N = 10
        a = [x for x in range(1,  N+1)]
        bit = [0] * N
        t = 10
        f(0,N,0,t)
        ```
        
        - 고려사항을 잘 정하면 도는 횟수가 줄어든다! 
  
- 백트래킹 vs DFS(깊이우선탐색)
  - 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임(Prunning 가지치기: 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다.)
  - DFS
    - 모든 경로 추적.
    - 경우의 수가 많다. N! 가지 경우의 수를 가진 문제에 대해 DFS 가하면 처리 불가
  - 백트래킹
    - 불필요한 경로를 조기에 차단. 모든 후보를  검사하지 않는다
    - 최악의 경우에는 지수함수시간(exponential Time)을 필요로 하여 처리 불가



##  분할정복 알고리즘

- 설계전략

  - 분할: 해결할 문제를 여러 개의 작은 부분으로 나눈다.
  - 정복: 나눈 작은 문제를 각각 해결한다
  - 통합: 필요하다면 해결된 해답을 모은다

- 예제

  - 거듭제곱

    - 시간복잡도: O(log n)
    - C^n = C^(n/2)  *  C^(n/2) (짝수일 때)
    - C^n = C^((n-1)/2) *  C^((n-1)/2) *C (홀수일 때)

    ```python
    def Power(Base, Exponent):
        if Exponent == 0 or Base == 0;
        return 1
    	
        if Expnent % 2 == 0:
            NewBase = power(Base, Exponent/2)
            return NewBase * NewBase
        else:
            NewBase = power(Base, (Exponent-1)/2)
            return (NewBase * NewBase) * Base
    ```

    

## 퀵 정렬

- 주어진 배열을 두개로 분할하고, 각각을 정렬한다.
- 시간 복잡도: O(n^2)
- 평균 시간 복잡도: nlogn
- 합병정렬과 차이점
  - 합병정렬은 그냥 두 부분으로 나누는 반면, 퀵 정렬은 분할 시  기준 아이템(pivot item) 중심으로, 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
  - 각 부분 정렬이 끝난 후, 합병 정렬은 '합병'이란 후처리 작업이 필요하나, 퀵 정렬은 필요로 하지 않는다.

- [69, 10, 3, 2, 16, 8,31, 22] 퀵 정렬과정
  1. 원소 2를 피봇으로 선택하고 퀵 정렬 시작
     - L이 69에서 오른쪽으로 이동하여 피봇보다 크거나 같은 원소를 찾고, R은 22에서 왼쪽으로 이동하며 피봇보다 작은 원소를 찾는다.(찾으면 멈춘다)
     - L은 69를 찾았고, R은 찾지 못하고 L과 만남. => 69와 피봇을 교환. 피봇 원소 2의 위치 확정
  2. 피봇 2의 왼쪽 부분 집합은 공집합 => 퀵정렬 수행x. / 오른쪽 부분 집합에 대해 퀵 정렬 수행
     - 오른쪽 부분집합에서 가운데의 원소 16을 피봇으로 선택
     - L이 찾은 30과 R이 찾은 8을 서로 교환
     - 현재 위치에서 L과 R의 작업 반복
     - L은 69를 찾았지만 R은 찾지 못한채 L과 만남 => 69와 피봇을 교환해 피봇 원소 16의 위치 확정
  3. 피봇 16의 왼쪽 부분 집합에서 원소 10을 피봇으로 선택하여 퀵 정렬 수행
  4. 피봇 10의 확정된 위치에서의 왼쪽 부분 집합은 원소가 한 개이므로 퀵 정렬을 수행하지 않고, 오른쪽 부분 집합은 공집합이므로 역시 퀵 정렬을 수행하지 않는다.
  5. ...

```python
def quickSort(a, begin, end):
    if begin<end:
        p = partition(a, begin, end)
        quickSort(a, begin, p-1)
        quickSort(a, p+1, end)
def partition(a, begin, end):
    pivot = (begin+end)//2
    L = begin
    R = end
    while L<R:
        while(L<R and a[L]<a[pivot]): L += 1
        while(L<R and a[L]>=a[pivot]): R -= 1
        if L<R:
            if L==pivot: pivo = R
            a[L], a[R] = a[R], a[L]
        a[pivot], a[R] = a[R], a[pivot]
        return R
```













