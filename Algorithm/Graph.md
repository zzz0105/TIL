# 그래프

## 그래프 기본

- 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현
- 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조
  - |V|: 정점의 개수
  - |E|: 그래프에 포함된 간선의 개수
  - |V|개의 정점을 가지는 그래프는 최대 |V| * (|V| - 1) / 2 간선이 가능
- 선형 자료구조나 트리 자료구조로 표현하기 어려운 N:N 관계를 가지는 원소들을 표현하기에 용이하다

### 그래프의 유형

- 무향 그래프
- 유향 그래프(간선이 화살표로)
- 가중치 그래프(간선 위에 비용 적어둠)
- 사이클 없는 방향 그래프(DAG)
- 완전 그래프: 정점들에 대해 가능한 모든 간선들을 가진 그래프
- 부분 그래프: 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

### 인접 정점

- 인접(Adjacency)
  - 두 개의 정점에 간선이 존재(연결됨)하면 서로 인접해 있다고 한다
  - 완전 그래프에 속한 임의의 두 정점들은 모두 인접해있다.

### 그래프 경로

- 경로: 간선들을 순서대로 나열한 것
  - 간선들: (0,2),(2,4),(4,6)
  - 정점들: 0-2-4-6
- 단순 경로: 경로 중 한 정점을 **최대한 한번만** 지나는 경로
- 사이클: 시작한 정점에서 끝나는 경로

### 그래프 표현

- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접 행렬
  - |V| x |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장
  - 행 번호와 열번호는 그래프의 정점에 대응
  - 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
  - 무향 그래프
    - i번째 행의 합 = i번째 열의 합=Vi의 차수
  - 유향 그래프
    - 행 i의 합 = Vi의 진출 차수(Vi에서 나가는 것이 몇 개인지)
    - 열 i의 합 = Vi의 진입 차수(Vi로 들어오는 것이 몇 개인지)
- 인접 리스트
  - 각 정점마다 해당 정점으로 나가는 간선의 정보를 저장
  - 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장
  - 무방향 그래프
    - 노드 수 = 간선의 수 * 2
    - 각 정점의 노드 수 = 정점의 차수
  - 방향 그래프
    - 노드 수 = 간선의 수
    - 각 정점의 노드 수 = 정점의 진출 차수

- 간선의 배열
  - 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장 

## 그래프 탐색

- 그래프 순회는 비선형구조인 그래프로 표현된 모든 자료(정점)를 빠짐없이 탐색하는 것을 의미

- 방법

  - 깊이 우선 탐색

    - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, <u>가장 마지막에 만났던 갈림길 간선</u><u>이 있는 정점</u>으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 모든 정점을 방문하는 순회 방법
    - <u>가장 마지막에 만났던 갈림길의 정점</u><u>으로 되돌아가서</u> 다시 깊이 우선 탐색을 반복해야 하므로 **후입선출 구조의 스택 혹은 재귀**를 사용
      - 스택: 선형구조(1 대 1의 관계). 후입선출.

    ```python
    #재귀_실제 경로 저장
    def dfs(v, V):
        visited[v] = 1
        for w in range(1, V+1):	#v에 인접한 모든 노드에 대해
            if adjM[v][w]==1 and visited[w]==0:
                dfs(w, V)
                
    #스택_갈림길 저장
    def dfs(v, V):
        stack = [v]             # 스택생성,시작정점 push
        visited = [0]*(V+1)
        while stack:
            v = stack.pop()
            if visited[v]==0:
                print(v)            # visit()
                visited[v] = 1
                for w in range(1, V+1):
                    if adjM[v][w]==1 and visited[w]==0: #인접, 미방문w
                        stack.append(w)
    ```

  - 너비 우선 탐색

    - 탐색 시작점의 인접한 정점들을 <u>먼저 모두 차례로 방문</u>한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
    - <u>인접한 정점들에 대해 탐색</u>을 한 후, 차례로 다시 너비 우선탐색을 진행해야 하므로, **선입선출 형태의 자료구조인 큐**를 활용함
      - 큐: 선형구조(1 대 1의 관계). 선입선출.

    ```python
    def bfs(s, V):
        q = []                  # 큐샐성
        visited = [0]*(V+1)     # vistied생성
        q.append(s)             # 시작점 인큐
        visited[s] = 1          # 시작점 인큐 표시
        while q:
            v = q.pop(0)        # 디큐
            print(v, end = ' ')
            for w in range(1, V+1):
                if adjM[v][w]==1 and visited[w]==0:
                    q.append(w)
                    visited[w] = visited[v] + 1
        return
    ```

    

## 서로소 집합들

- 서로소 또는 상호배타 집합들은 서로 중복 포함된 원소가 없는 집합들이다. (= 교집합이 없다)
- 집합에 속한 하나의 특정 멤버를 통해 각 집합들을 구분한다. 이를 대표자(대표 원소)라고 한다.
- 상호배타 집합을 표현하는 방법
  - 연결 리스트
    - 같은 집합의 원소들은 하나의 연결리스트로 관리. 연결리스트의 맨 앞의 원소를 집합의 대표 원소로 삼는다.
    - 각 원소는 집합의 대표원소를 가리키는 링크를 갖는다
  - 트리
    - 하나의 집합을 하나의 트리로 표현
    - <u>자식 노드가 부모 노드를 가리키며</u> **루트 노드가 대표자**가 된다.
      - 대표 원소는 자기 자신을 가리킨다.
      - 자식을 인덱스로 부모 번호를 저장하는 방법 사용
    - 대표원소의 개수 = 자기 자신을 가르키는 원소의 개수 = 트리의 개수
- 상호배타 집합 연산
  - Make-Set(x): **x를 대표원소**로 하는 집합을 만든다
  - Find-Set(y): y가 속한 집합의 **대표 원소**를 반환
  - Union(x,y): x와 y를 포함하는 두 집합을 합친다. **x를 합친 집합의 대표원소로** 삼는다.



## 최소 비용 신장 트리(MST)

- 신장 트리: n개의 정점으로 이루어진 <u>무방향 그래프</u>에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리(Minimum Spanning Tree): 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

### MST를 찾는 알고리즘

#### Prim 알고리즘

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어가는 방식
  1. 임의 정점을 하나 선택해서 시작
  2. 선택한 정점과 인접하며 MST에 포함되지 않은 정점들 중 MST에 속해있는 전체 정점에 대해  **최소 비용의 간선**이 존재하는 정점을 선택
     - MST에 포함된 정점들도 포함해 구성하게 된다면 사이클이 생긴다.
  3. <u>모든 정점이 선택될 때까지</u> 위 과정 반복
- 서로소인 2개의 집합(2 disjoint-sets) 정보를 유지.(포함/미포함 구분해주면 됨)
  - 트리 정점들 - MST를 만들기 위해 선택된 정점들
  - 비트리 정점들 - 선택되지 않은 정점들

#### KRUSKAL 알고리즘

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
  1. 최초, 모든 간선을 <u>**가중치**에 따라 오름차순으로 정렬</u>
  2. 가중치가 가장 <u>낮은 간선부터 선택하면서 트리를 증가</u>시킴
     - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
     - 상호배타집합을 활용하여 사이클 형성을 막는다.
       - findset(v1)!=findset(v2)이면 union(v1,v2)
  3. n-1개의 간선이 선택될때까지 2번 반복



## 최단 경로

> 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로

- 하나의 시작 정점에서 끝 정점까지의 최단경로
  - 다익스트라(Dijkstra) 알고리즘
    - 음의 가중치를 허용하지 않음
  - 벨만-포드 알고리즘
    - 음의 가중치 허용
- 모든 정점들에 대한 최단 경로
  - 플로이드-워샬 알고리즘

### 다익스트라 알고리즘

- 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식
- 시작정점(s)에서 끝정점(t)(s에서 갈 수 있는 곳)까지의 최단 경로에 정점x가 존재한다. 이 때, 최단 경로는 s에서 x까지의 최단 경로와 x에서 t까지의 최단경로로 구성된다. 이 둘 중 더 작은 값으로 갱신해준다.
- 탐욕기법을 사용한 알고리즘. MST의 프림 알고리즘과 유사