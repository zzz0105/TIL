# 완전 검색 & 그리디

## 반복(Iteration)과 재귀(Recursion)

> 반복과 재귀는 유사한 작업을 수행할 수 있다.

### 반복

> 수행하는 작업이 완료될 때까지 계속 반복

- 초기화: 반복되는 명령문을 실행하기 전에 조건 검사에 사용할 변수의 초기값 설정
- 조건 검사(check control expression)
- 반복할 명령문 실행(action)
- 업데이트(loop update): 무한 루프가 되지 않게 조건이 거짓이 되게 한다.

### 재귀

> 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
>
> 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합한다.

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
- 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀 호출은 반복적인 스택의 사용을 의미하여 메모리 및 속도에서 성능 저하가 발생한다.
- 두 부분으로 나뉜다
  - 기본 부분(basis part): 집합에 포함되어 있는 원소. induction을 생성하기 위한 시드 역할.
  - 유도 부분(inductive part): 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

### 반복과 재귀의 비교

|                | 재귀                                    | 반복                  |
| -------------- | --------------------------------------- | --------------------- |
| 종료           | 재귀 함수 호출이 종료되는 베이스 케이스 | 반복문의 종료 조건    |
| 수행 시간      | (상대적) 느림                           | 빠름                  |
| 메모리 공간    | (상대적) 많이 사용                      | 적게 사용             |
| 소스 코드 길이 | 짧고 간결                               | 길다                  |
| 소스 코드 형태 | 선택 구조(if...else)                    | 반복 구조(for, while) |
| 무한 반복 시   | 스택 오버플로우                         | CPU를 반복해서 점유   |

- 입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.



## 완전검색기법

### 고지식한 방법(brute-force)

> 문제를 해결하기 위한 간단하고 쉬운 접근법

- 대부분의 문제에 적용 가능하며, 상대적으로 빠른 시간에 알고리즘 설계를 할 수 있다
  - 모든 경우의 수를 생성하고 테스트한다. -> 수행속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
  - 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개성을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.
- 문제에 포함된 자료의 크기가 작다면 유용하다. 
- 알고리즘의 효율성을 판단하기 위한 척도로 사용된다.

### 완전 검색

- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것
- 전형적으로 순열, 조합, 그리고 부분집합과 같은 조합적 문제들과 연관
- 완전 검색은 조합적 문제에 대한 brute-force 방법



## 조합적 문제

### 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- nPr: 서로 다른 n개 중 r개를 택하는 순열
  - nPr = n * (n-1) * (n-2) * (n-2) * ... * (n-r+1)
  - nPn = n!(팩토리얼) = n * (n-1) * (n-2) * (n-2) * ... * 2 *1

* 재귀 호출을 통한 순열 생성

  ```python
  def perm(n, k,m):
      if n==k:
          print(arr)	#원하는 작업 수행
      else:
          for i in range(m):
              if used=[i]==0:
                  used[i]=1
                  p[n]=arr[i]
                  perm(n+1,k,m)
                  used[i]=0
  arr=[1,2,3,4]
  p = [0]*3	#고를 숫자만큼 만들어주면 된다
  used = [0]*len(arr)
  f(0,3, len(arr))		#전체에 대한 순열이 아니라면 몇개 고를지에 대한 정보도 넘겨야한다.
  ```

### 부분집합

- N개의 원소를 포함한 집합
  - 자기 자신과 공집합을 포함한 모든 부분집합(powerset)의 개수는 2^n개
  - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

### 조합

> 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

- nCr = n!/((n-r)!*r!) = **n-1 C r-1 + n-1C r**(재귀적)
- nC0 = 1