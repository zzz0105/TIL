# 완전 검색 & 그리디

## 반복(Iteration)과 재귀(Recursion)

> 반복과 재귀는 유사한 작업을 수행할 수 있다.

### 반복

> 수행하는 작업이 완료될 때까지 계속 반복

- 초기화: 반복되는 명령문을 실행하기 전에 조건 검사에 사용할 변수의 초기값 설정
- 조건 검사(check control expression)
- 반복할 명령문 실행(action)
- 업데이트(loop update): 무한 루프가 되지 않게 조건이 거짓이 되게 한다.

### 재귀

> 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
>
> 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합한다.

- 함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수
- 함수 호출은 프로그램 메모리 구조에서 스택을 사용한다. 따라서 재귀 호출은 반복적인 스택의 사용을 의미하여 메모리 및 속도에서 성능 저하가 발생한다.
- 두 부분으로 나뉜다
  - 기본 부분(basis part): 집합에 포함되어 있는 원소. 유도 부분을 생성하기 위한 시드 역할.
  - 유도 부분(inductive part): 새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

### 반복과 재귀의 비교

|                | 재귀                                    | 반복                  |
| -------------- | --------------------------------------- | --------------------- |
| 종료           | 재귀 함수 호출이 종료되는 베이스 케이스 | 반복문의 종료 조건    |
| 수행 시간      | (상대적) 느림                           | 빠름                  |
| 메모리 공간    | (상대적) 많이 사용                      | 적게 사용             |
| 소스 코드 길이 | 짧고 간결                               | 길다                  |
| 소스 코드 형태 | 선택 구조(if...else)                    | 반복 구조(for, while) |
| 무한 반복 시   | 스택 오버플로우                         | CPU를 반복해서 점유   |

- 입력 값 n이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.



## 완전검색기법

### 고지식한 방법(brute-force)

> 문제를 해결하기 위한 간단하고 쉬운 접근법

- 대부분의 문제에 적용 가능하며, 상대적으로 빠른 시간에 알고리즘 설계를 할 수 있다
  - 모든 경우의 수를 생성하고 테스트한다. -> 수행속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
  - 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개성을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.
- 문제에 포함된 자료의 크기가 작다면 유용하다. 
- 알고리즘의 효율성을 판단하기 위한 척도로 사용된다.

### 완전 검색

- 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 것
- 전형적으로 순열, 조합, 그리고 부분집합과 같은 조합적 문제들과 연관
- 완전 검색은 조합적 문제에 대한 brute-force 방법



## 조합적 문제

### 순열

- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- nPr: 서로 다른 n개 중 r개를 택하는 순열
  - nPr = n * (n-1) * (n-2) * (n-2) * ... * (n-r+1)
  - nPn = n!(팩토리얼) = n * (n-1) * (n-2) * (n-2) * ... * 2 *1

```python
#재귀
def perm(arr, n):
	result = []
	if n == 0:
		return [[]]
	for i in range(len(arr)):
		elem = arr[i]
		for rest in perm(arr[:i] + arr[i+1:], n - 1):
			result.append([elem] + rest)
	return result

#반복문 활용
arr = [1,3,5,7,10]
n = len(arr)
for i in range(n):
    for j in range(n):
        for k in range(n):
            if i != j and j != k and k != i:
                print(i,j,k)

#itertools의 permutations를 활용해 구할 수도 있다.
from itertools import permutations
arr = [1,3,5,7,10]
nums = list(permutations(arr,3))
```

### 부분집합

- N개의 원소를 포함한 집합
  - 자기 자신과 공집합을 포함한 모든 부분집합(powerset)의 개수는 2^n개
  - 원소의 수가 증가하면 부분집합의 개수는 지수적으로 증가

```python
arr = [1,4,6,8,16,29]
n = len(arr)
#반복문 활용
subsets=[[]]
for a in arr:
    for y in range(len(subsets)):
        subsets.append(subsets[y]+[a])

#바이너리 카운팅 활용
for i in range(0,1<<n):
    for j in range(n):
        if i&(1<<j):	#i의 j번째 비트가 1일 때
            print(arr[j], end=' ')
    print()
```

### 조합

> 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것

- nCr = n!/((n-r)!*r!) = **n-1 C r-1 + n-1C r**(재귀적)
- nC0 = 1

```python
#재귀 호출 활용
def com(arr, n):
    result = []
    if n==0:
        return [[]]
    for i in range(len(arr)):
        elem = arr[i]
        for C in com(arr[i+1:],n-1):
            result.append([elem]+C)
    return result
        
#반복문 활용
arr = [3,6,1,7,8]
n = len(arr)
for i in range(n):
    for j in range(i+1,n):
        for k in range(j+1,n):
            print(i,j,k)
            
#itertools의 combinations를 활용할 수도 있다
from itertools import combinations
arr = [3,6,1,7,8]
nums = list(combinations(menu,2))
```



## 탐욕 알고리즘

- 최적해를 구하는데 사용되는 근시안적인 방법. 머리속에 떠오르는 생각을 검증없이 바로 구현하면 Greedy 접근이다. 하지만 **최적이라는 보장은 없다.**
- 한번 선택된 것은 번복하지 않는다. -> 단순하며 제한적인 문제들에 적용됨
- 최적화 문제: 가능한 해들 중에서 가장 좋은 해를 찾는 문제
- 동작 과정
  1. 해 선택: 부분 문제의 최적 해를 구한 뒤 이를 부분해집합에 추가
  2. 실행 가능성 검사: 새로운 부분 해 집합이 실행가능한지(제약 조건을 위반하지 않는지)를 확인.
  3. 해 검사: 새로운 부분 해 집합이 문제의 해가 되는지를 확인

- 탐욕 기법과 동적 계획법의 비교

  | 탐욕 기법                                                    | 동적 계획법                                          |
  | ------------------------------------------------------------ | ---------------------------------------------------- |
  | 매 단계에서 가장 좋게 보이는 것을 빠르게 선택. <br />-> 지역 최적 선택 | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 함 |
  | 하위 문제를 풀기 전, 탐욕적 선택이 먼저 이루어짐             | 하위 문제가 우선 해결된다                            |
  | Top-down 방식                                                | Bottom-up 방식                                       |
  | 일반적으로, 빠르고 간결하다.                                 | 좀 더 느리고 복잡하다                                |
