# 분할정복 & 백트래킹

## 분할정복

- 설계전략
  - 분할(Divide): 해결할 문제를 여러 개의 작은 부분으로 나눈다
  - 정복(Conquer): 나눈 작은 문제를 각각 해결한다
  - 통합(Combine): 필요하다면, 해결된 해답을 모은다
- Top-down 방식

### 거듭제곱

- 반복 알고리즘 활용 시 시간 복잡도: O(n)
- 분할 정복 기반의 알고리즘: O(log n)

### 병합 정렬(Merge Sort)

- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 외부 정렬의 기본이 되는 정렬 알고리즘
- 분할 정복 알고리즘 활용. top-down 방식
- 시간 복잡도: O(n logn)
- 과정
  - 분할단계: 전체 자료 집합에 대하여 최소 크기의 부분집합이 될때까지 분할 작업을 계속한다
  - 병합단계: 2개의 부분집합을 <u>정렬하면서</u> 하나의 집합으로 병합. 비교해서 작은 쪽을 택함
- 분할할 때마다 메모리 추가로 사용. 병합 시에는 분할하면서 만들어놓았던 메모리에 사용하면 된다

```python
#분할 단계
def mergeSort(arr):
    if len(arr)==1:
        return arr
    left, right = [], []
    middle = len(arr)//2
    for x in range(middle):
        left.append(x)
    for x in range(middle,len(arr)):
        right.append(x)
    left = mergeSort(left)
    right = mergeSort(right)
    return merge(left, right)
    
#병합 단계
def merge(left, right):
    result = []
    while len(left) > 0 or len(right) > 0:
        if len(left) > 0 and len(right) > 0:
            if left[0]<=right[0]:
                result.append(left.pop(0))
            else:
                result.append(right.pop(0))
        elif len(left)>0:
            result.append(left)
        elif len(right)>0:
            result.append(right)
	return result
```

### 퀵 정렬

- 주어진 배열을 두 개로 분할하고, 각각을 정렬한다
- 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘
- 병합 정렬과 다른 점
  - 퀵정렬은 분할 할 때, pivot(기준) 중심으로, 이보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
  - 각 부분 정렬이 끝난 후, 병합 정렬은 후처리 작업(병합)이 필요하지만, 퀵정렬은 필요로 하지 않는다.
- 과정
  - 피봇 선택: 왼쪽 끝, 오른쪽 끝, 임의의 세개 값 중에 중간 값 
  - i는 왼쪽에서 시작하여 피봇 값보다 큰 요소를, j는 오른쪽에서 시작하여 피봇값보다 작은 요소을 찾는다. 찾은 후에 i,j가 가리키고 있는 요소의 자리를 교환시킨다.
  - i와 j가 교차하면 i, j는 피봇을 기준으로 작은 값과 큰 값들의 경계에 위치한다.
  - 새로 생긴 왼쪽/오른쪽 집합에서 퀵 정렬 수행

```python
#1 Hoare-Partition 알고리즘
#Lomuto partition 알고리즘보다 빠르다
def partition(arr, l, r):
    p = arr[l]	#피봇 값
    i = l+1
    j = r
    while i<=j:	#교차하기 전까지 
        while i<j and arr[i]<=p:
            i+=1
        while i<j and arr[j]>=p:
            j-=1
        #i는 피봇보다 작은 애 중에 가장 오른쪽에 있는 요소를 가리킴
        #j는 피봇보다 큰 애 중에 가장 왼쪽에 있는 요소를 가리킴
        if i<j:	 
            arr[i],arr[j] = arr[j],arr[i]
    arr[l],arr[j] = arr[j],arr[l]	#피봇의 자리를 j로 잡아준다~
    return j

#2 Lomuto-partition 알고리즘
def partition(arr,p,r):
    x = arr[r]
    i = p-1
    for j in range(p,r):
        if arr[j]<=x:
            i+=1
            arr[i],arr[j] = arr[j], arr[i]
        arr[i+1],arr[r] = arr[r], arr[i+1]
        return i+1
    
#quicksort
def quickSort(arr, l, r):
    if l<r:
        s = partition(a,l,r)
        quickSort(arr,l,s-1)
        quickSort(arr,s+1,r)
```

### 이진 검색(Binary Search)

- 자료의 가운데에 있는 항목의 **키 값과 비교**하여 **다음 검색의 위치를 결정**하고 검색을 계속 진행하는 방법.
  - 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 **검색 범위를 반으로 줄여가면서** 보다 빠르게 검색을 수행함
- 이진 검색을 하기 위해서는 **자료가 정렬된 상태**여야 한다
- 과정
  1. 자료의 중앙에 있는 원소 고른다
  2. 중앙 원소의 값과 찾고자 하는 값을 비교
  3. 중앙 원소의 값보다 작다면 왼쪽에 있는 원소들에 대해 새로 검색을 수행한다. 크다면 오른쪽 반에 대해 새로 검색 수행
  4. 찾을 때까지 반복

```python
#반복 활용
def binarySearch(arr, k):	#k는 찾을 요소 
    low = 0
    n = len(arr)
    high = n-1
    while low<=high:
        mid = low + (high-low)//2
        if arr[mid] == key:
            return mid
        elif s[mid]>key:
            high = mid-1
        else:
            low = mid + 1
    return -1

#재귀 활용
def binarySearch(arr, low, high, key):
    if low>high:
        return -1
    else:
        mid = (low+high)//2
        if key == arr[mid]:
            return mid
        elif key<arr[mid]:
            return binarySearch(arr, low, mid-1, key)
        else:
            return binarySearch(arr, mid+1, high, key)  
```



## 백트래킹

- 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 감
  - 유망하지 않다 = 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없다.
  - Pruning(가지치기): 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다.
- 백트래킹 vs 깊이 우선 탐색(DFS)
  - 백트래킹은 불필요한 경로를 조기에 차단(시도의 횟수를 줄인다.)
    깊이우선 탐색은 모든 경로를 추적한다. 
  - 백트래킹 알고리즘 적용 시 일반적으로 경우의 수 줄어듬.(최악의 경우에는 지수함수 시간이 필요함. 처리 불가.)
    깊이 우선 탐색을 가하기에는 경우의 수가 너무나 많다. **N!** 가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 한다면 처리가 불가능할 것
- 과정
  1. 상태 공간 트리의 깊이 우선 검색을 실시한다
  2. 각 노드가 유망한지 점검
  3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.



## 트리

- 정의
  - 싸이클이 없는 무향 연결 그래프
    - 두 노드(혹은 정점) 사이에는 유일한 경로가 존재
    - 각 노드는 최대 하나의 부모 노드가 존재할 수 있다
    - 각 노드는 자식 노드가 없거나 하나 이상이 존재할 수 있다
  - 비선형 구조
    - 원소들 간에 1:n 관계를 가지는 자료구조
    - 원소들 간에 계층관계를 가지는 계층형 자료구조
  - 한 개 이상의 노드로 이루어진 유한 집합.
    - 루트: 노드 중 부모가 없는 노드. 레벨0.(높이 0)
    - 나머지 노드들은 n개의 분리집합으로 분리될 수 있다. 분리집합들은 각각 하나의 트리가 된다(재귀적 정의)
    - 트리의 차수: 노드에 연결된 자식노드의 수 중 가장 큰 값
    - 

### 이진 트리

- 모든 노드들이 최대 2개의 서브 트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대 2개까지만 가질 수 있다
- 특성
  - 레벨 i에서의 노드의 최대 개수는 2^i개
  - 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h+1개. 최대 개수는 2^(h+1)-1개

#### 종류

##### 포화 이진 트리

- 모든 레벨에 노드가 포화상태로 채워져 있는 이진 트리
- 높이가 h일 때, 최대의 노드 개수인  2^(h+1)-1개의 노드를 가짐
- 루트를 1번으로 하여  2^(h+1)-1번까지 정해진 위치에 대한 노드 번호를 가짐

##### 완전 이진 트리

- 높이가 h이고 노드 수가 n개일 때(2^h <= n < 2^(h+1)-1), 포화 이진 트리의 노드 번호 1~n번까지 빈 자리가 없는 이진 트리

##### 편향 이진 트리

- 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리
- 순차적으로 탐색하므로, 트리의 특성이 없어짐. 효율 떨어진다.

#### 순회

- 트리의 각 노드를 중복되지 않게 전부 방문하는 것. 

  - 트리는 비선형 구조이기 떄문에 선후 연결 관계를 알 수 없다

- 3가지 기본적인 순회 방법

  - 전위 순회

    ```python
    def preorder(T):
        if T:
            visit(T)
            preorder(T.left)
            preorder(T.right)
    ```

  - 중위 순회

    ```python
    def inorder(T):
        if T:
            inorder(T.left)
            visit(T)
            inorder(T.right)
    ```

  - 후위 순회

    ```python
    def postorder(T):
        if T:
            postorder(T.left)
            postorder(T.right)
            visit(T)
    ```

- 배열을 이용한 이진 트리의 표현

  - 이진 트리에 각 노드 번호를 다음과 같이 부여
    - 루트 번호를 1로 부여
    - 레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2^n ~ 2^(n+1)-1까지 번호를 차례로 부여
  - 노드 번호의 성질
    - 노드 번호가 i인 노드의 부모 노드 번호: i//2
    - 노드 번호가 i인 노드의 왼쪽/오른쪽 자식 노드 번호: 2 * i / 2 * i + 1
    - 레벨 n의 노드 시작 번호 2^nn 

### 이진 탐색 트리

- 탐색 작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 유일한 키를 가지며, 루트노드의 key는 왼쪽 서브 트리의 key보다 크고 오른쪽 서브 트리의 key보다 작다
  - 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다
- 중위 순회 시 오름차순으로 정렬된 값을 얻을 수 있다
- 탐색 연산 과정
  - 루트에서 탐색을 시작한다
  - 탐색할 키 값을 루트 노드의 키 값과 비교
    - 같으면 탐색 성공
    - 탐색할 키가 더 작다면 루트노드의 왼쪽 서브 트리에 대해서 탐색 연산 수행
    - 탐색할 키가 더 크다면 루트노드의 오른쪽 서브 트리에 대해서 탐색 연산 수행
  - 서브 트리에 대해서도 순환적으로 탐색 연산 반복
  - 탐색을 수행할 서브트리가 없으면 탐색 실패
- 삽입 연산 과정
  - 탐색연산을 수행
    - 같은 원소가 트리에 있는지 탐색하여 확인(삽입할 원소와 같은 원소가 트리에 있으면 삽입 불가하므로)
    - 탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 된다
  - 탐색 실패한 위치에 원소 삽입

- 삭제 연산 과정
  - 삭제할 노드가 리프 노드인 경우
    - 탐색-삭제
  - 삭제할 노드가 리프 노드가 아닌 경우
    - 차수가 1인 경우
      - 탐색 - 삭제 - 서브 트리 이동
    - 차수가 2인 경우
      - 탐색 - 후보 찾기 - 이동
        - 후보는 왼쪽 서브 트리 중 가장 큰 요소와 오른쪽 서브 트리 중 가장 작은 요소

#### 이진 탐색 트리 성능

- 시간 복잡도 O(h). h는 BST의 깊이
  - 탐색, 삽입, 삭제 시간은 트리의 높이만큼 시간이 걸린다.
- 평균의 경우: O(log n)
  - 이진 트리가 균형적으로 생성되어 있는 경우
- 최악의 경우: O(n)
  - 한쪽으로 치우친 편향 이진 트리의 경우 
  - 순차탐색과 시간복잡도가 같다

### 힙

- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 최대 힙
  - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - 부모 노드의 키 값 > 자식 노드의 키 값
  - 루트 노드: 키 값이 가장 큰 노드
- 최소 힙
  - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - 부모 노드의 키 값 < 자식 노드의 키 값
  - 루트 노드: 키 값이 가장 작은 노드
- 힙 정렬
  - 이진 탐색과 유사한 방법으로 수행됨
  - 단계
    1. 하나의 값을 힙에 삽입(반복)
    2. 힙에서 순차적으로(오름차순) 값을 하나씩 제거함
  - 시간 복잡도
    - N개의 노드 삽입 연산+N개의 노드 삭제 연산
    - 삽입과 삭제 연산은 각각 O(logn) => 전체 정렬은 O(n log n)
- 힙의 활용
  - 특별한 큐의 구현
  - 정렬
    - 힙 정렬은 배열에 저장된 자료를 정렬하기에 유용하다
  - 힙은 우선순위 큐를 구현하는 가장 효율적인 방법
    - 노드 하나 추가/삭제의 시간 복잡도가 O(logn)이고 최대값/최소값을 O(1)에 구할 수 있다
    - 완전 정렬보다 관리 비용이 적다
  - 배열을 통해 트리 형태를 쉽게 구현할 수 있다
    - 부모나 자식 노드를 O(1)연산으로 쉽게 찾을 수 있다
    - n위치에 있는 노드의 자식은 2n과 2n+1에 위치함
    - 완전 이진 트리의 특성에 의해 추가/삭제의 위치는 자료의 시작과 끝 인덱스로 쉽게 판단할 수 있다