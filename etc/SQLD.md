# SQLD

## 1과목 1장: 데이터 모델링의 이해

- 발생시점에 따른 엔터티 분류
  - 기본/키엔터티
  - 중심엔터티
  - 행위엔터티
  
- 데이터모델링
  - 데이터모델링이란?
    - 정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법
    - 현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정
    - 데이터베이스를 구축하기 위한 분석/설계의 과정
    - [참고]소프트웨어 개발 방법론
      1. 데이터 구조화론: 업무에만 집중한다. 절차도에 따른 프로그래밍
         	ex. 책 판다 - 돈 받는다 - 매출 상승.
      2. <u>관계형 데이터베이스</u>: 데이터 자체와 관계에 집중. 핵심적 정보를 연결지어 유기체적으로 모든 업무를 포괄할 수 있도록 함
         	ex. 프로세스가 다른 업무들도 진행하면 정보를 따로 쓰게된다. data 중복 & data quality  감소 -> 관계형 데이터 베이스 도입
      3. ~~객체지향 데이터베이스~~
  - 데이터 모델링 유의점
    - 중복
    - 비유연성
    - 비일관성
  - 종류
    - 개념적 데이터 모델링: 추상화 수준이 높고 업무중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA 수립 시 많이 사용
    - 논리적 데이터 모델링: 시스템으로 구축하고자하는 업무에 대해 Key, 속성, 관계 등을 정확하게 표현, 재사용성이 높음
    - 물리적 데이터 모델링: 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계
  
- 데이터베이스 스키마 구조 3단계
  - 외부 스키마
  - 개념 스키마
  - 내부 스키마
  
- 엔티티

  - 업무 상 관리하고자하는 대상

  - 특징

    - 관계는 1개 이상 가져야 한다

    - 반드시 해당 업무에서 필요하고 관리하고자하는 정보이어야 한다
    - 유일한 식별자에 의해 식별이 가능해야 한다
    - 영속적으로 존재하는 인스턴스의 집합이어야 한다(두 개 이상)
    - 엔터티는 업무 프로세스에 의해 이용되어야 한다
    - 엔터티는 반드시 속성이 있어야 한다(2개 이상)
    - 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다

  - 분류

    - 유무형에 따른 분류
      - 유형: 물리적 형태			ex. 사원, 물품
      - 개념: 개념적 정보			ex. 조직, 상품
      - 사건: 업무 수행 시 발생  ex. 주문, 미납
    - 발생시점에 따른 분류
      - 기본: 업무에 원래 존재하는 정보.				ex. 사원, 부서
      - 중심: 기본 엔티티로부터 발생				      ex. 계약, 주문
      - 행위: 2개 이상의 부모 엔티티로부터 발생  ex. 주문 목록

- 속성

  - 관리하고자하는 대상인 인스턴스의 집합
  - 분류
    - 기본: 업무로부터 추출한 모든 일반적인 속성
    - 설계: 업무를 규칙화하기 위해 새로 만들거나 변형    ex. 일련번호
    - 파생: 다른 속성에 영향을 받아 발생하는 속성            ex. 합
  - 속성의 명칭 부여
    - 해당업무에서 사용하는 이름을 부여한다
    - 서술식 속성명은 사용하지 않는다
    - 약어사용은 가급적 제한한다
    - 전체 데이터모델에서 유일성 확보하는 것이 좋다

- 엔터티, 인스턴스, 속성, 속성값의 관계

  - 한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다
  - 한 개의 엔터티는 두 개 이상의 속성을 갖는다
  - 한 개의 속성은 한 개의 속성 값을 갖는다

- 도메인

  - 지정해줄 수 있는 것: 유형, 크기, 제약조건
  - 물리적 데이터 모델링 - check, primary key 등이 도메인에 해당

- 관계

  - 관계의 표기법

    - 관계명: 관계의 이름
    - 관계차수(Cardinality): 1:1, 1:M, M:N
    - 관계선택사양: 필수관계, 선택관계
    - IE 표기법
      - 표처럼 생김. 맨 위에는 pk를 써주고 나머지 일반 속성들은 그 아래에 써준다
      - 필수관계는 |, 선택관계는 o|로 표기한다.(상대 쪽에 표기함)
    - Barker 표기법
      - 둥근 박스를 쓰고, 식별자는 #, 나머지는 o으로 표기한다
      - 필수관계는 실선, 선택관계는 점선으로 표기(자신에게 표기)
  - 관계 읽기

    - 기준 엔터티를 한 개 또는 각으로 읽는다
    - 대상 엔터티의 관계참여도, 즉 개수를 읽는다.
    - 관계선택사양과 관계명을 읽는다.

- 식별자

  - 식별자/비식별자 관계

    |                        | 식별                                                         | 비식별                                                       |
    | ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | **관계**               | 강한 관계                                                    | 약한 관계                                                    |
    | **단점**               | SQL 구분이 복잡해짐                                          | 느리다.                                                      |
    | 단점 이유              | PK가 계속 상속해서 내려가므로 PK 속성 수 증가                | 불필요한 조인 관계가 많이 생겨서                             |
    | 표기(ERD. IE에만 존재) | 실선                                                         | 점선                                                         |
    | 자식 주식별자 영향     | 자식 주식별자의 구성에 포함됨                                | 자식 일반 속성에 포함됨                                      |
    | 연결 고려사항          | - 반드시 부모엔터티 종속<br />- 자식 주식별자 구성에 부모 주식별자 포함 필요<br />- 상속받은 주식별자속성을 타엔터티에 이전 필요 | - 자식 주식별자 구성을 독립적으로 구성<br />- 자식 주식별자구성에 부모 주식별자 부분 필요<br />- 상속받은 주식별자속성을 타 엔터티에 차단 필요<br />- 부모 쪽의 관계 참여가 선택관계 |

  - 식별자의 종류

    - 엔터티 내에서 **대표성**을 가지는가에 따라 <u>주식별자와 보조식별자</u>로 구분

      - 주식별자: 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이며, 타 엔터티와 참조관계를 연결할 수 있는 식별자

        - 주식별자의 특징

          - 유일성: 주식별자에 의해 엔터티 내에 모든 인스턴스들을 유일하게 구분함
          - 최소성: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
          - 불변성: 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야 함
          - 존재성: 주식별자가 지정되면 반드시 데이터 값이 존재(NOT NULL)

          다 만족하면 후보키, 대표로 선정된 것이 PK이다. 
          PK + 대체키 = 후보키

      - 보조식별자: 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계 연결을 못함

    - 엔터티 내에서 **스스로 생성**되었는지 여부에 따라 <u>내부식별자와 외부식별자</u>로 구분

      - 내부식별자: 엔터티 내부에서 스스로 만들어지는 식별자
      - 외부식별자: 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자

    - **단일 속성으로 식별**이 되는가에 따라 <u>단일식별자와 복합식별자</u>로 구분

      - 단일식별자: 하나의 속성으로 구성된 식별자
      - 복합식별자: 둘 이상의 속성으로 구성된 식별자

    - 원래 업무적으로 의미가 있던 식별자 속성을 대체하여 일련번호와 같이 **새롭게 만든 식별자**를 구분하기 위해 <u>본질식별자와 인조식별자</u>로 구분

      - 본질식별자: 업무에 의해 만들어지는 식별자
      - 인조식별자: 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자

- ERD
  - ERD 작성 순서
    1. 엔터티를 그린다
    2. 엔터티를 적절하게 배치한다
    3. 엔터티간 관계를 설정한다
    4. 관계명을 기술한다
    5. 관계의 참여도를 기술한다
    6. 관계의 필수여부를 기술한다
  - ERD 서술 특징
    - 시선 때문에 좌상 -> 우하로 움직여야 한다
    - 관계명 반드시 표기하지 않아도 된다
    - UML은 객체지향에서만 사용된다
  - ERD에서는 존재적 관계와 행위에 의한 관계를 구분하지 않지만 클래스 다이어그램에서는 이것을 구분하여 연관관계와 의존 관계로 표현한다

## 1과목 2장: 데이터 모델과 성능

- 성능데이터 모델링이란?
  
  - 데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것이다
  - 방법
    - 아키텍처 모델링 수정: 데이터 베이스 구조를 바꾼다 -> 더 성능이 좋고 효과적이다
      - 아키텍처: 테이블, 파티션
      - 테이블 분할, 파티션 분할 등
    - SQL 명령문 수정
      - 조인수행 원리
      - 해시 조인
      - 옵티마이저
      - 실행계획
  
- 정규화

  - 중복속성에 대한 분리가 1차 정규화의 대상이 되며, 로우단위의 중복도 1차 정규화의 대상이 되지만 칼럼 단위로 중복이 되는 경우도 1차 정규화의 대상이다

  - 정규화 수행 방법 및 예시

    - 제 1 정규화: 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블 분해
    - 제 2 정규화: 완전 함수 종속을 만족하도록 테이블 분해(PK의 부분집합이 결정자가 되지 않도록)
    - 제 3 정규화: 이행적 종속(A -> B, B -> C가 성립할 때 A -> C가 성립되는 것)을 없애도록 테이블 분해
    - BCNF 정규화: 모든 결정자가 후보키가 되도록 테이블 분해
    - 제 4 정규화: 다치 종속 제거
    - 제 5 정규화: 조인 종속 제거

    - 이상현상 
      - 삭제 이상: 한 튜플을 삭제할 때 연쇄 삭제 -> 정보 손실 
      - 삽입 이상: 데이터 삽입 시 원하지 않는 값도 같이 삽입됨
      - 갱신 이상: 튜플의 속성값을 갱신할 때 일부 튜플의 정보만 갱신됨 -> 정보의 모순
    - 성능 
      - select에서는 join 때문에 느려질 수 있다
      - Insert update는 성능 증가(테이블이 작아지기 때문)

    정규화는 성능 모델링 전에 한 후에 시작해야한다

- 반정규화
  - 반정규화란
    - 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다
    - 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있고 좀 더 넓은 의미의 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있고 좀 더 넓은 의미의 반정규화는 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미한다
    - **데이터 무결성이 깨질 수 있는 위험**을 무릅쓰고 데이터를 중복하여 반정규화를 적용하는 이유는 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다
  - 절차
    1. 반정규화 대상조사
       - 범위처리빈도수 조사
       - 대량의 범위 처리 조사
       - 통계성 프로세스 조사
       - 테이블 조인 개수
    2. 다른 방법유도 검토
       - 뷰 테이블
       - 클러스터링 적용
       - 인덱스의 조정
       - 응용애플리케이션
    3. (2번 방법들이 통하지 않을 때)반정규화 적용
       - 테이블 반정규화
         - 병합: 1:1, 1:M, 슈퍼/서브타입 병합
         - 분할: 수직/수평 분할
       - 속성의 반정규화
         - 파생 컬럼 추가
         - 응용 시스템 오작동을 위한 칼럼 추가
         - 이력 테이블 컬럼 추가
         - pk에 의한 칼럼 추가: pk를 일반속성으로 편입
         - 이력 테이블 칼럼 추가
       - 관계의 반정규화
         - 중복 관계 추가
  - 반정규화의 대상에 대해 다른 방법으로 처리
    - 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰를 사용하면 이를 해결할 수도 있다
    - 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우에 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있다
    - 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다. 즉 파티셔닝 기법이 적용되어 성능저하를 방지할 수 있다
    - 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다
  
- 슈퍼/서브타입
  
  - 용량별로 처리가 가능
    - 적은 경우에는 one to one 테이블 사용
      - 트랜잭션이 개별로 들어간다
    - 큰 경우 바로 트랜잭션 유형으로 분류
  - 트랜잭션 유형에 따라서 
    - 공통/차이점에 따라서 별개로 트랜잭션 들어간다
      - 슈퍼 서브 타입이라는 크로스타입을 사용함
    - 전체 테이블 통합으로 트랜잭션이 들어감(싱글 타입_하나의 통합된 테이블)
  - 슈퍼/서브 타입 데이터 모델의 변환기술
    - 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
    - 슈퍼타입 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
    - 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성
  
- pk순서를 결정하는 기준은 인덱스 정렬구조를 이해한 상태에서 인덱스를 효율적으로 이용할 수 있도록 pk순서를 지정해야한다. 즉 인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다. 앞쪽에 위치한 속성 값이 가급적 '=' 아니면 최소한 범위 'BETWEEN' '<>'가 들어와야 인덱스를 이용할 수 있는 것이다.

- 분산 데이터베이스 
  
  - 데이터 베이스를 여러 개의 서버로 뜯어놓는것(반정규화와 유사) → 데이터 무결성을 해침	
    
  
  - 장점
    - 지역 자치성, 정증적 시스템 용량 확장
    - 신뢰성과 가용성
    - 효용성과 융통성
    - 빠른 응답 속도와 통신비용 절감
    - 데이터의 가용성과 신뢰성 증가
    - 시스템 규모의 적절한 조적
    - 각 지역 사용자의 요구 수용 증대
  - 단점
    - 소프트웨어 개발 비용
    - 오류의 잠재성 증대
    - 처리 비용의 증대
    - 설계, 관리의 복잡성과 비용
    - 불규칙한 응답 속도
    - 통제의 어려움
    - 데이터 무결성에 대한 위협

## 2과목 1장 SQL 기본 

### DCL: Data Control Language

> 데이터베이스 사용자에게 권한을 부여/회수하는 언어

- GRANT: 권한 부여
  - GRANT 권한 ON 테이블 TO 유저;
- REVOKE: 권한 회수
  - REVOKE 권한 ON 테이블 FROM 유저;
- 권한의 종류: SELECT,INSERT,UPDATE,DELETE / REFERENCES,ALTER,INDEX / ALL
  - WHERE 조건문을 사용가능하게 하려면 SELECT 권한 부여해야 한다
  - ROLE이란? 
    - 다양한 권한을 다양한 유저를 대상으로 관리하기 위한 명령어. 
    - 다양한 권한을 하나의 그룹으로 묶어서 관리할 수 있도록 하는 논리적인 권한의 그룹. 
    - 여러 사용자에게 동일한 ROLL 부여 가능하다. 
    - ROLE의 생성은 CREATE ROLE 권한을 가진 유저가 할 수 있다.(사용자는 Role에 Role을 부여할 수도 있다)
- GRANT 옵션
  - TO 유저 WITH GRANT OPTION;
    - 특정 사용자에게 권한 부여 가능한 권한 부여
    - 엄마가 회수될 때 자식도 회수됨
  - TO 유저 WITH ADMIN OPTION;
    - 테이블에 대한 모든 권한 부여
    - 엄마의 권한 회수는 나와 상관이 없다

### DDL: Data Definition Language

> 데이터를 보관하고 관리하기 위한 객체의 구조를 정의하기 위한 언어. SQL 서버에서 자동으로 DB에 반영

- CREATE: 데이터베이스 상 테이블 구조 생성

  ```sql
  CREATE TABLE C_INFO (		 --테이블 이름 C_INFO
      이름		varchar2(10),	--컬럼명과 컬럼의 속성 정의
      생년		number(4) default 9999,
      phone	 varchar2(15) not null,
      첫방문일   date,
      고객번호   varchar2(10) primary key
  );	
  ```

  - 구조

    - 컬럼명의 시작은 무조건 문자로. 영어, 한글, 숫자 모두 가능

      +) 테이블명의 시작은 무조건 문자로. 영어, 숫자, _, #, $ 모두 가능
      		다른 테이블명과 중복되지 않아야하고, 칼럼 뒤 데이터 유형은 꼭 지정되어야 함

    - 데이터 타입

      - number: 숫자형
      - date: 날짜형
      - varchar2: 가변길이 문자열
        - '호호' != '호호   '
      - char: 고정된 크기 문자열 할당된 길이만큼 문자를 채움
        - '호호' = '호호   '

  - 제약조건(CONSTRAINT)

    - default: 기본값 지정
    - not null: null 입력 불가
      - null: 모르는 값. 값이 없음(부재)을 의미. null과의 모든 비교 및 연산은 null값을 반환하며, NULL **IS** NULL = TRUE. NULL은 숫자0이나 공백문자와 동일하지 않음.
      - count(*): 전체 행의 수 카운트, null 포함
      - count(컬럼명): null 제외한 행 수 카운트
    - primary key: 기본키 지정
      - pk는 not null. unique한 값(테이블 내 중복 없음)
    - foreign key: 외래키 지정. 테이블 당 여러개 가능

- ALTER: 테이블과 칼럼에 대해 이름 및 속성 변경, 추가/삭제 등 구조 수정을 위해 사용

  ```sql
  -- 	테이블			명령		대상
  ALTER TABLE MENU RENAME TO MENU;	--테이블명 변경
  RENAME TABLE MENU TO MENU	--테이블명 변경(다수 테이블명 동시에 변경 가능)
  ALTER TABLE MENU RENAME COLUMN phone TO 전화번호;	   --컬럼명 변경
  ALTER TABLE MENU MODIFY (이름 varchar(20) not null);	--칼럼 속성 변경
  ALTER TABLE MENU ADD (거주지역 varchar(10));	--칼럼 추가
  ALTER TABLE MENU DROP COLUMN 이름;			 --칼럼 삭제
  ALTER TABLE MENU ADD CONSTRAINT; 	--제약조건 추가
  ALTER TABLE MENU DROP CONSTRAINT;	--제약조건 삭제
  ```

- RENAME: 이름 변경

- DROP: 테이블 및 칼럼 삭제

  ```sql
  ALTER TABLE MENU DROP COLUMN 이름;	--칼럼 삭제
  DROP TABLE MENU;		--테이블 삭제
  ```

  - 테이블 삭제 유의사항
    - DROP TABLE MENU CASCADE CONSTRAINT;	
      - 해당 테이블의 데이터를 외래키로 참조한 제약사항도 모두 삭제
      - ORACLE에만 있는 조건. SQL SERVER에는 존재하지 않음
      - FK제약조건과 참조테이블 먼저 삭제하고, 해당 테이블을 삭제한다

- TRUNCATE: 테이블 초기화

  - DROP vs. TRUNCATE

    ```sql
    DROP TABLE MENU;		--테이블 관련해서 모두 삭제. (구조와 데이터도)
    TRUNCATE TABLE MENU;	--테이블 데이터만 삭제되고 구조는 살아있다
    ```

    - DROP
      - DDL
      - 테이블 정의를 완전 삭제
      - 테이블이 사용했던 모든 저장공간을 Release됨
      - 건물 철거. 구조 삭제
    - TRUNCATE
      - DML
      - 테이블을 초기상태로 만듦(뼈대만 살렸다) 
      - 테이블 최초 형성 시 사용했던 저장공간만 남기고 Release
      - 입주민 퇴거. 구조 남음. log data 남음

### DML: Data Manipulation Language

> 정의된 데이터베이스에 레코드를 입력하거나, 수정, 삭제 및 조회하기 위한 명령어다.

```sql
INSERT INTO MENU (NAME) VALUES ('연어스시');
UPDATE MENU SET discount_rate = 10 (where name = '연어스시');
DELETE FROM MENU (WHERE name='연어스시')

UPDATE MENU SET 메뉴코드 =100 WHERE 메뉴명='연어스시'
DELETE MENU
INSERT INTO MENU (메뉴코드, 가격, 메뉴명) VALUES ('100', 1000, '연어스시')
INSERT INTO MENU VALUES ('100', '연어스시', 300, 0)	--튜플
```

- INSERT: 데이터 입력
  - 칼럼명 지정이 이뤄지지 않은 상태에서는 전체값이 들어가야함
  - not null 값인 메뉴명에 대한 insert가 이뤄지지 않을 때 (지정한 매개변수와 value의 개수가 다를 때) 오류 발생
  
- UPDATE: 데이터 수정
  
  - COL1 컬럼에 행이 3개가 있는데 UPDATE 테이블 SET COL1=50이라고 하면 모든 행의 값이 50으로 바뀐다
  
- DELETE: 데이터 삭제
  - DELETE에서 FROM 생략 가능. DELETE MENU 가능
  - 숫자는 varchar2와 char에 입력 가능.
  - 삭제된 데이터에 대해 로그를 남길 수 있는 방법. DB에 반영되기 전까지 삭제된 데이터를 다시 되돌릴 수 있다
    → 데이터는 삭제되지만 용량이 줄어들지 않는다.
  - 특정행을 삭제할 수 있다

- MERGE: INSERT, UPDATE, DELETE를 한번에 수행

  - data를 한번에 업데이트하여 훨씬 빠르게 결과를 얻을 수 있다(index를 가진 데이터의 경우 더욱 빠름)

- SELECT: 조회

  - **SELECT** 조회대상(컬럼명 등) **FROM** 테이블명 **WHERE** 조건문 **GROUP BY** 집계기준컬럼명 **HAVING** grouping된 후 상태 기반의 조건문 **ORDER BY** 컬럼명

    - 실행 순서: SELECT ALIAS > FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY

  - 예시

    INFO

    | 유저코드 | 성별 | 이름 |
    | -------- | ---- | ---- |
    | 1A       | F    | A    |
    | 2A       | M    | B    |
    | 3A       | M    | C    |
    | 4A       | F    | D    |
    | 5A       |      | E    |

    ```sql
    SELECT COUNT(*) FROM C_INFO      	   --5
    SELECT COUNT(성별) FROM C_INFO		  --4
    SELECT COUNT(DISTINCT 성별) FROM C_INFO --3
    ```
    - **SELECT DISTINCT**: <u>중복값 없이</u> 가져오는 것. NULL도 단일 행으로 본다. 만약 DISTINCT가 두 컬럼에 대해 적용되었다면 컬럼의 조합에서 중복을 제거하고 조회한다
      - DISTINCT A, B = DISTINCT (A, B) ≈ GROUP BY (A, B)

  - SELECT문 기본 구조 - 문자형 함수

    ```sql
    LOWER('SQL')			--'sql'
    UPPER('sql')			--'SQL'
    CONCAT('S'+'QL') = 'S'||'QL' = 'S'+'QL'	--'SQL'
    SUBSTR('SQL',2,2)		--'QL'
    LEN('S QL')				--4
    TRIM('AABBCCAA', 'A')	--'BBCC'
    TRIM(' AABBCCAA ',)		--'AABBCCAA'	지정된 문자 없으면 공백 제거
    LTRIM('AABBCCAA', 'A')	--'BBCCAA'
    LTRIM(' AABBCCAA ',)	--'AABBCCAA '
    RTRIM('AABBCCAA', 'A') 	--'AABBCC'
    RTRIM(' AABBCCAA ',)	--' AABBCCAA'
    
    SELECT TRIM(유저코드, 'A'), LOWER(이름) FROM INFO	
    --INFO 테이블에서 양쪽에서 A를 제거한 유저코드, 소문자로 나타낸 이름을 조회
    SELECT T1.* FROM table1 T1, table2 T2 WHERE UPPER(T1.col1) LIKE T2.col1
    /* T1(테이블1)의 col1을 대문자로 변환한 결과가 T2(테이블2)와 유사한 경우 둘을 접합시키고 T1에 있는 모든 것을 조회 */
    ```

    - LOWER(문자열): 영어 문자열 소문자로 변환
    - UPPER(문자열): 영어 문자열 대문자로 변환
    - CONCAT(문자열1, 문자열2): 문자열 1과 문자열2를 결합.(인수가 반드시 2개여야 한다)
      - +(SQL server), ||(oracle)
    - SUBSTR(문자열,m,n): 문자열에서 <u>m번째 자리값부터 n개</u>를 자른다
      - 길이를 쓰지 않으면 끝까지. 
    - LENGTH(문자열) = LEN(문자열): <u>공백을 포함</u>하여 문자열의 길이값
    - TRIM(문자열, 제거대상): 왼쪽과 오른쪽에서 지정된 문자를 삭제한다(지정된 문자 없으면 공백 제거)
      - LTRIM(문자열, 제거대상): 왼쪽에서 지정된 문자를 삭제한다
      - RTRIM(문자열, 제거대상): 오른쪽에서 지정된 문자를 삭제한다
    - LPAD(값, 총 문자길이, 채움문자): 지정한 길이만큼 왼쪽부터 특정 문자로 채워줌
      - 채움문자를 지정하지 않으면 공백으로 해당길이만큼 문자를 채운다
    - RPAD(값, 총 문자길이, 채움문자): 지정한 길이만큼 오른쪽부터 특정 문자로 채워줌
      - 채움문자를 지정하지 않으면 공백으로 해당길이만큼 문자를 채운다
    - INSTR(문자열, 찾을 문자열, 시작 위치, 발생횟수): 문자열에서 찾고자 하는 문자열과 일치하는 위치를 반환
      - 시작위치와 발생횟수의 디폴트 값은 1이다.
    - REPLACE(문자열 혹은 열 이름, 바꾸려는 문자열, 바뀔 문자열): 특정 문자열을 찾아 바꾸는 함수

  - SELECT문 기본 구조 - 숫자형 함수

    ```sql
    ROUND(25.3467, 2)	--25.35
    TRUNC(25.3467, 2)	--25.34
    CEIL(25.3427)		--26
    FLOOR(25.3427)		--25
    MOD(25, 7)			--4
    SIGN(25.3427)		--1
    ABS(25.3427)		--25.3427
    ```

    - ROUND(숫자, 소숫점 자릿수): 반올림
    - TRUNC(숫자, 소숫점 자릿수): 버림
    - CEIL(숫자): 크거나 같은 최대 정수 반환
    - FLOOR(숫자): 작거나 같은 최대 정수 반환
    - MOD(분자, 분모): 분자를 분모로 나눈 나머지 반환
    - SIGN(숫자): 숫자가 양수면 1, 0이면 0, 음수면 -1 반환
    - ABS(숫자): 절댓값

  - SELECT문 기본 구조 - 날짜형 함수

    ```sql
    SELECT SYSDATE FROM DUAL	--2022/05/23 11:45:23(datetime 형태)
    --DUAL은 오라클이 설치될 때 만들어지는 테이블. 산술, 날짜 처리 등을 하는 기본 임시 테이블
    EXTRACT(YEAR FROM sysdate)	--2022
    EXTRACT(YEAR FROM sysdate) TO_NUMBER(TO_CHAR(sysdate, 'YYYY')) --2022
    ```

    - SYSDATE: 쿼리를 돌리는 현재 날짜 & 시각 출력(ORACLE)
    - GETDATE: SQL server에서 현재 시간을 출력해주는 함수
    - 날짜 데이터 + 100은 100일 이후를 뜻한다
    - EXTRACT(정보 FROM 날짜): 날짜형 데이터에서 원하는 값을 출력함
      - 정보: YEAR, MONTH, DAY, HOUR, MINUTE, SECOND

  - SELECT문 기본 구조 - 명시적/암시적 형변환

    > 명시적 형변환: 형변환 함수를 사용하여 강제로 data type을 변경하는 것
    >
    > 암시적 형변환: 데이터베이스가 알아서 바꿔주는 것 
    > 	ex. where pk='12' -> 인덱스에 대해 암시적 형변환이 발생. 인덱스를 사용할 수 없다

    ```sql
    TO_NUMBER('2022')	--2022
    TO_CHAR(date '2022-02-11', 'day')	--'금요일'
    TO_CHAR(200)		--'200'
    TO_DATE('20220523', 'YYYYMMDDHH24')	--2022/05/23 23:00:00
    SELECT TO_CHAR(SYSDATE-1, 'YYYYMMDD') FROM DUAL;	--어제 날짜 조회
    ```

    - TO_NUMBER(문자열): 문자열을 숫자로 변환
    - TO_CHAR(숫자 or 날짜, 포맷): 숫자 혹은 날짜형 데이터를 포맷에 맞게 문자로 바꿈
    - TO_DATE(문자열, 포맷): 날짜형으로 변환

  - SELECT문 기본 구조 - DECODE, CASE WHEN

    ```sql
    DECODE(B, C, '나', '너')		--'너'
    
    DECODE(A, 1, 'a',   -- null은 생략 가능
              2, 'b',   
              3, 'c',   
                ,'d')  
    --A가 1이면 a, 2이면 b, 3이면 c, 이외에는 d를 출력  
    
    CASE WHEN col1 < 10 THEN '한자릿수'
         WHEN col1 BETWEEN 10 AND 99 THEN '두자릿수'
         ELSE '세자릿수'
    END
    SELECT 회원코드 AS ID, 연령 AS AGE, 이름 AS NAME
    FROM INFO
    ORDER BY (CASE WHEN 회원코드=101 OR 회원코드=104 THEN 1 ELSE 2 END), 연령 DESC 
    /* AS는 ALIAS의 줄임말. 컬럼명을 변경하여 출력되도록 도움.
    SELECT절에서의 as: as 생략 가능. column 명에 띄어쓰기가 있는 경우
    FROM절에서의 as: as 사용 불가
    ORDER BY 2개 기준으로 정렬됨. 마지막으로 수행됨
    회원코드가 101 또는 104일 때 기준1이 1, 그외에는 2. 말이 없으면 ASC정렬
    (출력되지 않는다. 정렬할 때만 쓰는 것)
    기준2는 AGE*/
    ```

    - DECODE(값1, 값2, 값1=값2일 때 출력값, 서로 다를 때 출력값): IF문과 비슷

    - CASE WHEN 조건 THEN 조건이 참일 때 결과 ELSE 거짓일 때 결과 END

      ```sql
      case 조건 when 결과1 then 출력1
      		 when 결과2 then 출력2	
      		 else 출력3	--else가 없는 경우 조건1, 조건2 만족하지 않을 때 null이 출력됨
      end 컬럼명
      ```

  - SELECT문 기본 구조 - WHERE 조건문

    - IN (x,y,z): x, y, z 등으로 구성된 목록 내 값 중 어느 하나라도 일치하면 된다

    - NOT IN (x,y,z): x, y, z 등으로 구성된 목록 내 값 중 어느 하나라도 일치하면 안된다

    - IS NULL: NULL인지 판단. NULL일 경우 TRUE. 표현식 두 개의 데이터 타입이 같아야 함

      - ISNULL(생일,9999) -> 생일이 NULL이면 9999 표시

    - IS NOT NULL: NULL이 아닌지 판단. NULL이 아닌 경우 TRUE

    - BETWEEN a AND b: a와 b 사이에 값이 있는지

    - Rownum (oracle)

      - where 조건절에서 Rownum이 1인 경우 포함
        - Rownum은 적층구조. 범위형태로 주어야 한다. 

      - ex. select from empno, cell where rownum<=3 order by sal desc
        - order by sal이 가장 마지막에 시행된다. 따라서 정렬 전에 rownum에 의한 조건절이 시행된다. 따라서 rownum이 3이하인 것을 뽑고 난 후에 그 행에 대해 내림차순으로 정렬된 것이 출력된다.

    - Top (sqlserver)

      - Top (n) <컬럼명>: select 절에서 컬럼명을 출력할 때 상위 n개의 행을 가져온다.

    - 비교연산자(=, >, >=, <, <=)

    - 논리 연산자

      - 종류

        - and: A와 B를 모두 만족
        - or: 하나 이상의 조건이 만족
        - not: 조건을 부정

      - 연산순위

        1. not
        2. and
        3. or

        ex. not <조건1> and <조건2> and not <조건3> or <조건4>: 조건1과 조건3을 부정한다. 그 후 and를 계산하고 or을 계산한다.

    - 문자열 조건문 관련 연산자

      ```sql
      SELECT * FROM words WHERE 단어 LIKE 'li%' ORDER BY 1
      --여기서 1은 조회된 테이블의 컬럼순서 번호
      
      SELECT * FROM INFO WHERE ROWNUM=1; 
      --ROWNUM: 조회된 행이 몇번째 행인지 부여해줌
      --ROWID: 데이터베이스에 저장되어 있는 데이터를 구분할 수 있는 유일한 값
      --SQL SERVER에서는 TOP(1), MySQL에서는 LIMIT1
      
      WITH TableName AS (SELECT * FROM INFO WHERE NAME LIKE '%a%')
      --이름에 a가 들어가는 사람들 대상으로 임시테이블 만들고 전체를 조회하기
      
      SELECT * FROM(SELECT * FROM INFO WHERE name LIKE '%a%')
      --서브쿼리
      ```

      - A **LIKE** B: A에 대하여 B와 유사한 문자열을 찾아줌
      - 와일드카드
        - %: 문자 0개 이상이 존재한다는 의미
        - _: 문자 한 개
      - escape
        - 와일드카드인 _와 %를 문자로 취급해주는 함수
          - 예시
            - name like 'A@_A' escape '@': _를 문자로 취급하게 된다.
            - name like '%#%%' escape '#': 문자 %를 포함한 것을 찾는다.

      - WITH 구문
        1. 서브쿼리를 사용해서 임시테이블이나 뷰처럼 사용 가능함
           - 서브쿼리: SELECT 문 내에 SELECT 문이 또 쓰여있는 쿼리
              - 뷰 테이블: 일종의 가상테이블로서 실제 데이터가 하드웨어에 저장되는 것은 아니다. 실제 데이터를 가지고 있지 않다. 테이블 구조가 변경되더라도 독립적으로 존재. 사용상의 편의. 수행속도 향상. 보안성.
        2. 별칭 지정 가능함
        3. 인라인뷰나 임시테이블로 판단
           - 인라인뷰: 서브쿼리가 FROM 절 내에 쓰여진 것

  - SELECT문 기본 구조 - NULL 관련 함수(null: 부재. 모르는 값)

    ```sql
    NVL(col1, 100) 			-- col1이 NULL이면 100으로 바꿔줌. 
    NVL2(col1, 'F', 'T')	--col1이 NULL이면 'F', 아니면 'T' 출력
    NULLIF(1,2)				--1
    COALESCE(NULL,2,3)		--3
    ```

    - NVL(col1, 대체값): NULL이면 다른 값으로 바꿔주는 함수(null이 아니면 col1값) 표현식 두 개의 데이터 타입이 같아야 함

    - NVL2(col1, 결과1, 결과2): col1이 NULL이면 결과1, 아니면 결과2

    - NULLIF(v1, v2): v1과 v2가 같으면 NULL, 다르면 V1을 출력

    - isNull(v1, v2): v1이 null이면 값2, 아니면 값1

    - COALESCE(v1, v2, ... , vn): NULL이 아닌 최초의 값을 반환

    - 정렬 시 null의 의미: ∞ (oracle),  -∞(SQL server)

    - NULL과의 연산

      - | A    | B    | C    |
        | ---- | ---- | ---- |
        | null | null | 1    |
        | 3    | 2    | 2    |
        | null | 2    | 3    |

        sum(A) = 3			sum(B) = 4		

        count(A) = 1		 count(*) = 3

        sum(A+B+C) = 7: 새로운 column을 만들고 풀어라. (A+B+C는 null 7 null로 나온다.)

        * SUM은 NULL을 빼고 처리
        * sum(A+B+C)와 sum(A) + sum(B) + sum(C)는 다르다

      - null은 산술 연산 시 null, 비교 연산 시 알 수 없음 나온다. (where 조건절 에 unknown이 들어오면 Flase로 판단)

  - SELECT문 기본 구조 - GROUP BY: DISTINCT한 값을 기준으로 묶어준다(집약기능)

    - 그룹 수준으로 정보를 바꿔준다. Having도 그룹에 대한 조건식

    - GROUP BY 안에서도 함수를 먹인 상태에서 집계를 해주어야 한다

    - 두 개의 컬럼으로 GROUP BY가 된다면, 각각 DISTINCT한 조합으로 함.

    - SELECT문 기본 구조 - 집계함수

      ```sql
      COUNT(*), COUNT(exp)		--COUNT(*): NULL 포함, COUNT(exp): NULL 제외
      SUM([DISTINCT|ALL] exp)		--합계
      AVG([DISTINCT|ALL] exp)		--평균
      MAX([DISTINCT|ALL] exp)		--최대값
      MIN([DISTINCT|ALL] exp)		--최소값
      STDDEV([DISTINCT|ALL] exp)	--표준편차
      VARIAN([DISTINCT|ALL] exp)	--분산
      -- NULL 값에 대한 연산 결과는 모두 NULL. 통계적 집계함수를 연산할 때 NULL을 제외하고 계산
      ```

  - SELECT문 기본 구조 - HAVING

    ```sql
    SELECT 성별, AVG(연령) FROM INFO GROUP BY 성별 HAVING AVG(연령)>=30 AND AVG(연령)<40	--성별의 평균 연령이 30대인 셩별의 성별과 평균 연령 출력
    ```

  - SELECT문 기본 구조 - ORDER BY

    - 컬럼 번호 정렬

      - 출력되는 컬럼의 수보다 큰 값이 <u>허용되지 않는다.</u>

      - 출력되지 않는 컬럼명으로 정렬 가능하다.

        ex. select name order by sal

    - 인수 2개의 정렬

      ex. sal desc, name asc: sal이 같은 경우 name 오름차순으로 정렬

  - <u>pivot/unpivot</u> 함수

    - pivot: SELECT 필드목록 FROM 테이블 PIVOT(집계함수 FOR 대상필드 IN (필드값 목록)) 
      - 행으로 나열되어있는 데이터를 열로 나열하여 보기 쉽게 가공함. 대상 필드의 값 목록을 새로운 열로 만들고 각 열에 대해 집계 함수를 호출하여 결과셋을 만든다.
    - unpivot: SELECT 가져올\_컬럼명, 데이터를\_재구축할\_컬럼명 FROM 테이블 UNPIVOT (검색할_열 FOR 대상칼럼 IN (언피봇 대상 컬럼 목록))
      - 피봇의 반대 동작을 수행(피봇과 완전한 반대 연산자는 아니다)

### TCL: Transaction Control Language

> 트랜잭션을 제어하기 위한 언어 

- COMMIT: 데이터에 대한 변화를 DB에 반영하기 위한 명령어
  - 영구적으로 반영이 됨 = COMMIT되어 DB에 들어감
- ROLLBACK: 코드를 분할하기 위한 저장 포인트 지정
  - SAVEPOINT가 쓰여있지 않을 경우 가장 최신의 COMMIT 상태로 복원된다
- SAVEPOINT: 트랜잭션이 시작되기 이전의 상태로 되돌리기 위한 언어. 
  최신 COMMIT이나 특수한 SAVEPOINT로 되돌릴 수 있는 명령어

- COMMIT과 ROLLBACK의 효과
  1. 데이터 무결성을 보장할 수 있다
  2. 영구적인 변경 전 데이터에 대한 변동사항을 확인할 수 있다
  3. 논리적 연관성 있는 작업을 그룹화하여 처리할 수 있다

+ 트랜잭션: 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위
  + 특징
    - 고립성: 트랜잭션이 **실행되는 동안** 다른 트랜잭션에 영향을 받아 잘못된 결과를 만들어선 안된다
    - 원자성: **all or nothing**. 트랜잭션에서 정의된 연산은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 있어야 한다
    - 지속성: 트랜잭션이 성공적으로 완료되면 해당 트랜잭션이 갱신한 데이터베이스의 내용은 **영구적으로 저장**
    - 일관성: 트랜잭션 발생 전 데이터베이스 내용에 잘못된 점이 없다면 트랜잭션 **수행 후**에도 데이터베이스의 내용에 잘못이 있으면 안된다
+ DDL의 커밋 기능 없애기: AUTO COMMIT OFF AND BEGIN TRANSACTION

## 2과목 2장 SQL 활용

- 그룹함수

  - SELECT 성별, 연령대, count(회원코드) FROM INFO GROUP BY 성별, 연령대

  - ROLLUP: n+1개의 부분합계와 전체 합계값을 보여준다. 인수의 순서에 영향을 받는다(계층구조로 진행되기 때문)

    ```sql
    SELECT 성별, 연령, SUM(결제금액) FROM 결제 GROUP BY ROLLUP(성별, 연령대) ORDER BY 성별, 연령;	--첫인자(성별)의 결제금액을 부분합계로 보여준다. 마지막엔 전체합
    ```

  - CUBE: 그룹화될 수 있는 <u>모든 경우</u>(2^n 가지)에 대해 생성. 계층 구조로 집계값을 반환

  - GROUPING SETS: 괄호 묶은 집합 별 집계 가능 

    - GROUPINGSETS(성별, 연령, (성별,연령),())이면 성별별 합계, 연령별 합계, 성별X연령 별 합계, 전체 합계를 얻을 수 있다. CUBE와 결과가 같다

  - 정리

  | SQL  구문                          | 결과                                                         |
  | ---------------------------------- | ------------------------------------------------------------ |
  | GROUP BY 성별, 연령                | 성별 X 연령 별 합계                                          |
  | GROUP BY ROLLUP(성별, 연령)        | 성별 X  연령 별 합계<br />성별 별 합계<br />전체 합계        |
  | GROUP BY CUBE(성별, 연령)          | 성별 X  연령 별 합계<br />성별 별 합계<br />연령 별 합계<br />전체 합계 |
  | GROUP BY GROUPING SETS(성별, 연령) | 성별 별 합계<br />연령 별 합계                               |

  - GROUPING 함수: 소계, 합계 등이 계산되면 1을 반환하고, 아니면 0을 반환한다

    - SELECT 성별, GROUPING(성별) g1, 연령대, GROUPING(연령대) g2, SUM(결제금액) FROM INFO GROUP BY ROLLUP(성별, 연령대) ORDER BY 성별, 연령;

      | 성별 | g1   | 연령대 | g2   | SUM(결제금액) |
      | ---- | ---- | ------ | ---- | ------------- |
      | F    | 0    | 10     | 0    | 10            |
      | F    | 0    | 20     | 0    | 30            |
      | F    | 0    |        | 1    | 40            |
      | M    | 0    | 30     | 0    | 15            |
      | M    | 0    | 40     | 0    | 55            |
      | M    | 0    |        | 1    | 70            |
      |      | 1    |        | 1    | 110           |

      ```sql
      --전체 합계 구분하고 싶다면
      SELECT 성별, CASE WHEN GROUPING(성별)=1 
      				 THEN '전체합계' END
      			AS g1
      		,연령, GROUPING(연령) g2, SUM(결제금액)
      FROM 결제
      GROUP BY ROLLUP(성별, 연령대)
      ORDER BY 성별, 연령대
      ```

    - INFO테이블과 PHONE 테이블이 있을 때 이름과 전화번호를 함께 조회하려고 한다

      - SELECT A.*, B.PHONE FROM INFO A INNER JOIN PHONE B ON A.회원코드=B.회원코드
        - A에서 다 가져오고 B에서 PHONE을 가져온다
    
  - 어떤 그룹함수를 썼는지 찾는 문제가 나왔을 때

    1. null을 모두 찾는다
    2. 총합 행이 있는지 찾는다.
       1. 있다면?
          - rollup: 한 쪽만 결과가 나오며 계층형태 가진다. 행의 수 적음
          - cube: 양 쪽으로 둘 다 결과가 나옴. 행의 수 많음
       2. 없다면?
          - groupingsets

- JOIN: 테이블 간의 결합. 집합과 유사함. 관련된 두 테이블에 적어도 하나의 공통 속성이 있을 때 적용 가능한 결합 방식(JOIN할수록 칼럼이 늘어난다). 

  - FROM A, B, C가 있을 때, A, B를 조인한 후 하나의 테이블이 되었을 때 C와 조인한다
  - 조인하는 방법
    1. 테이블 간 결합의 key가 되는 칼럼 찾기
    2. JOIN 방식에 따라 결과가 달라지기 때문에 KEY 컬럼값 간의 일치도 파악하기

  ![JOIN - 생활코딩](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/98/1861.png)

  - 교집합

    - INTERSECT

      ```sql
      SELECT A, B FROM TABLE1 INTERSECT SELECT A, B from TABLE2
      ```

    - INNER JOIN: 교집합이 되는 공통의 키값을 가진 값들만 출력
      - JOIN 예시
        - SELECT A.*, B.연령 FROM GENDER A <u>INNER JOIN</u> AGE B <u>ON</u> A.회원코드=B.회원코드;
          - GENDER을 A, AGE는 B라고 이름을 붙여줌. 회원코드(키)가 같은 경우 테이블 같이 보여줄 것이다. A의 모든 칼럼을 가져오고, B에서는 연령을 가져온다
            - B에서도 모든 칼럼을 들고 오게되면 칼럼이 겹치게 된다 -> 하나만 쓰기
        - SELECT A.*, B.연령 FROM GENDER A, AGE B <u>WHERE</u> A.회원코드=B.회원코드;
      - JOIN 후 특정 행만 호출할 때
        - SELECT A.*, B.연령 FROM GENDER A INNER JOIN AGE B ON A.회원코드=B.회원코드 WHERE A.성별='F';
        - SELECT A.*, B.연령 FROM GENDER A, AGE B WHERE A.회원코드=B.회원코드 AND A.회원='F'
      - 3개 이상의 테이블을 JOIN할 때
        - SELECT A.*, B.연령, C.생년 FROM GENDER A JOIN AGE B ON A.회원코드=B.회원코드 JOIN BIRTH C ON B.연령 = C.생년
        - SELECT A.*, B.연령 FROM GENDER A, BIRTH B WHERE A.회원코드=B.회원코드 AND B.연령=C.생년;

    - OUTER JOIN: 합집합
      - SELECT A.*, B.연령 FROM GENDER A FULL OUTER JOIN AGE B ON A.회원코드=B.회원코드;
      - SELECT A.*, B.연령 FROM GENDER A, AGE B WHERE A.회원코드**(+)**=B.회원코드**(+)**;

    - LEFT JOIN: A의 값(+)들은 다 나오고 B에서는 공통된 것만 붙이겠다. 없으면 NULL로. 
      - SELECT A.*, B.연령 FROM GENDER A LEFT JOIN AGE B ON A.회원코드=B.회원코드;
      - SELECT A.*, B.연령 FROM GENDER A, AGE B WHERE A.회원코드=B.회원코드**(+)**;
        회원코드가 조인키

    - RIGHT JOIN: B의 값(+)들은 다 나오고 A에서는 공통된 것만 붙이겠다. 없으면 NULL로.
      - SELECT B.회원코드, 성별 연령 FROM GENDER A LEFT JOIN AGE B ON A.회원코드=B.회원코드;
      - SELECT B.회원코드, 성별 연령 FROM GENDER A, AGE B WHERE A.회원코드**(+)**=B.회원코드;

  - 합집합: 동일한 컬럼 개수와 데이터타입을 가진 두 테이블을 합쳐줌. 테이블을 위, 아래로 합친다
    - UNION: 중복된 레코드가 제거됨(동일 컬럼구조, DATATYPE 동일 중복 제거)
      - SELECT * FROM T1 UNION SELECT * FROM T2
    - UNION ALL: 중복된 레코드가 제거되지 않음. 정렬 작업이 없어 UNION, INTERSECT, MINUS(EXCEPT)보다 빠르다
      - SELECT * FROM T1 UNION ALL SELECT * FROM T2
    
  - 차집합: MINUS(oracle) = EXCEPT(SQL SERVER)
    - A 회사의 고객만 추린다
      - SELECT * FROM A MINUS SELECT * FROM B
    
  - 결합되는 대상 간의 일치 정도 
    - EQUI 조인: 동일한 컬럼을 사용하여 두 릴레이션을 결합. 공통적으로 존재하는 칼럼의 값이 일치되는 행을 연결해서 결과를 생성
      - SELECT 테이블1.칼럼명, 테이블2.칼럼명 FROM   테이블1, 테이블2 WHERE  테이블1.칼럼명1 = 테이블2.칼럼명2; 
    - NON-EQUI 조인: 정확하게 일치하지 않는 칼럼들을 사용하여 두 릴레이션을 결합
      - SELECT 테이블1.칼럼명, 테이블2.칼럼명 FROM   테이블1, 테이블2 WHERE  테이블1.칼럼명1 BETWEEN 테이블2.칼럼명1 AND 테이블2.칼럼명2;
      - =을 사용하지 않음
      - A.key <, >, <=, >= B.key
    
  - NATURAL JOIN: 두 테이블 간의 동일한 이름을 갖는 모든 칼럼들에 대해 EQUI 조인

    - 중복된 칼럼이 사라짐(제일 앞에 등장하는 것 하나만 출력)
    - USING의 경우 ALIAS 사용 가능

  - CROSS JOIN: 서로 연관된 칼럼이 없을 경우 수행하는 조인. key 없이 JOIN하면 2개의 테이블에 대해 케테시안 곱 발생
    - 5*3=15개의 행이 조회된다
      - SELECT * FROM T1 CROSS JOIN T2
    
  - SELF JOIN: 한 테이블 내에서 연관관계를 가진 두 칼럼 간의 조인. 테이블 명과 컬럼명이 모두 일치하기 때문에 꼭 ALIAS를 써줘야 한다
    
    - SELECT T1.col1, T2.col1 From 테이블명 T1, 테이블명 T2 WHERE T1.col1=T2.col2

- SubQuery

  - 메인쿼리 vs 서브쿼리

    - SELECT COUNT(*) FROM 고객목록 WHERE 고객번호 NOT IN (SELECT 고객번호 FROM 연체자목록)
      - 전체: 메인 쿼리
      - (SELECT 고객번호 FROM 연체자목록): 서브쿼리. SELECT 안의 SELECT(SELECT, FROM, WHERE 절에 들어갈 수 있다)
    - 서브쿼리는 ORDER BY를 사용할 수 없다. 진짜로 보고자 하는 값이 아니기 때문에(있는지 없는지 이런게 중요함) ORDER BY는 있어도 필요가 없다.
    - 메인쿼리에서 서브쿼리의 컬럼을 자유롭게 사용할 수 없다. 
      서브쿼리 내부에서는 메인 쿼리의 칼럼을 쓸 수 있음. 
      메인 쿼리에서는 SELECT되지 않은 서브쿼리의 컬럼을 사용할 수 없음
    - EXIST가 반환하는 결과값은 True 혹은 False이다. 결과가 하나라도 존재하면 참.
      - ex. WHERE EXISTS (SELECT 1 FROM INFO WHERE 거주지='서울')
    - 상호연관 서브쿼리가 있을 때 select from A where (select from B...)
      - A 테이블 row를 하나 볼 때 전체 테이블 B를 본다. 

  - 이름이 있는 서브쿼리

    - 인라인뷰(Inline View):FROM 구에 SELECT 문이 있다. SQL 명령문 저장. 기본 테이블보다 저장 공간이 적게 필요함
      - **장점**
        - 독립성: 기존 table 구조가 변경되어도 view의 구조는 변경되지 않는다. view를 따로 업데이트하지 않아도 된다.
        - 편리성: 계속 테이블을 조작할 필요는 없다
        - 보안성: 원하는 정보만 가져올 수 있다
      - ex. FROM (SELECT * FROM 고객목록 WHERE 거주지='서울') A JOIN 연락처 B ON A.고객번호=B.고객번호
    - 스칼라 서브쿼리: SELECT 문에 들어가고, <u>한 행과 한 컬럼만 변환</u>하는 서브쿼리
      - ex. SELECT (SELECT(SUM(salary) FROM 급여 WHERE EXTRACT(YEAR FROM 급여지급일)=2021)...)

  - 절마다 사용되는 서브쿼리

    - select: scalar(단일 행 서브쿼리)
    - from: inline view(메인쿼리에 컬럼 사용 가능하다)
    - where: 거의 모든 서브쿼리(중첩서브쿼리)
    - group by: 서브쿼리가 들어가지 않는다
    - having: 거의 모든 서브쿼리(중첩서브쿼리)
    - order by: scalar

  - 단일행/다중행 서브쿼리(출력되는 행의 개수에 따라 정의)

    - SELECT COUNT(*) FROM 고객목록 WHERE 고객번호 NOT IN (SELECT 고객번호 FROM 연체자목록) → 다중행 서브쿼리(연체자목록이 여러행이 있으면)

      - 메인쿼리의 결과와 서브 쿼리의 결과가 모두 동일할 때 참이 되는 다중행 연산자는?

        ```sql
        50000 > ALL(20000,30000) 	--TRUE. 전체에 대해 50000이 더 큰가
        50000 > ANY(70000,30000)	--TRUE. 어느 것 하나라도 50000이 더 큰다
        50000 > ALL(70000,30000)	--FALSE. 전체에 대해 50000이 더 큰가
        ```

    - SELECT (SELECT(SUM(salary) FROM 급여 WHERE EXTRACT(YEAR FROM 급여지급일)=2021)...)  → 단일행 서브쿼리

- 계층형 조회: 트리 형태의 데이터에 대해 조회를 수행하는 것

  - 계층 구조 시작점(START WITH로 계층형 조회의 시작점을 설정) → 부모데이터, ROOT 노드. LV1

  - 자식 데이터: 부모 밑에 있는 데이터

  - LEAF 노드: 자식노드가 없는 데이터

  - 예시

    - SELECT col3 FROM 조직구조 START WITH col2 IS NULL CONNECT BY PRIOR col1=col2 ORDER SIBILNGS BY col3 DESC 했을 때의 결과는?

      | col1 | col2 | col3 |
      | ---- | ---- | ---- |
      | 11   |      | 10   |
      | 12   | 11   | 12   |
      | 13   | 11   | 13   |
      | 14   | 12   | 15   |

      - 계층형 조회문제는 조회를 통해 어떻게 레코드가 재배치 되는지 파악하는 것이 중요! 동일한 값을 가진 칼럼끼리 연결되어 재배치된다

      - START WITH: 계층 구조가 시작되는 지점을 알려줌. 여기에 적힌 조건에 맞는 레코드가 ROOT. 이 문제에서는 첫번째 레코드 행이 트리구조의 루트노드이다

      - CONNECT BY: 계층구조(트리)가 연결된 방향성을 알려줌. EX. 자식노드→부모노드, 부모노드 → 자식노드(순방향)

        - 모든 레코드에 대하여 관계성을 파악하면 재배치된 테이블에서 전체 레코드의 순서를 알 수 있다
        - CONNECT BY PRIOR a=b
          1. a컬럼과 b컬럼이 동일한 레코드들 간에 계층화가 발생한다.
          2. a→b 순으로 재배치된다(a가 부모의 키값. b가 자식의 키값)

      - ORDER SIBLINGS BY col3 DESC: col3 기준, 내림차순으로 배치 순서 결정

      - 결과
      
        | col1 | col2 | col3 |
        | ---- | ---- | ---- |
        | 11   |      | 10   |
        | 13   | 11   | 13   |
        | 12   | 11   | 12   |
        | 14   | 12   | 15   |

- 윈도우함수

  -  SELECT **WINDOW_FUNCTION**(ARGUMENTS) **OVER** (\[PARTITION BY 컬럼명]\[ORDER BY 컬럼명][WINDOWING]) FROM 테이블명;

    - WINDOW_FUNCTION: 윈도우 함수

      - 그룹 내 집계함수: COUNT, SUM, MIN, MAX, AVG 등

        - SELECT 매장코드, 지역명, SUM(판매량) OVER (PARTITION BY 지역명) col1 FROM 판매

      -  그룹 내 순위(RANK) 함수 → 자동적으로 순위로 정렬되는 것은 아니다. ORDER BY 필수

        - RANK: 동일한 순위에 대해 동일한 순위를 부여. 동일한 순위를 하나의 건수로 계산하지 않는다 → 1 2 2 4
        - DENSE_RANK: 동일한 순위에 대해 동일한 순위를 부여한다. 동일한 순위는 하나의 건수로 계산한다 → 1 2 2 3
        - ROW_NUMBER: 동일한 순위에 대해 고유한 순위를 부여한다 → 1 2 3

        SELECT 매장코드, 판매금액 ROW_NUMBER() OVER (ORDER BY 판매금액 DESC) FROM 판매

      - 그룹 내 비율 관련 함수

        - PERCENT_RANK: 값이 아닌, **순서**를 대상으로, 파티션 내에서의 순서별 백분율을 조회함
        - NTILE(n): 파티션별로 전체 건수를 N 등분한 값을 반환한다. N=4이면 4등분한 것 내에서 몇인지 조회
        - CUME_DIST: 파티션 내 전체에서 현재 행의 값 이하인 레코드 건수에 대한 누적 백분율을 조회. 누적 분포 상에 0~1 값을 가짐

      - 그룹 내 행 순서 함수

        - FIRST_VALUE: 파티션 내에서 가장 처음 나오는 값 반환. MIN과 동일한 결과
        - LAST_VALUE: 파티션 내에서 가장 마지막에 나오는 값 반환. MAX와 동일한 결과
        - LAG(컬럼명, 레코드 위치 차이값): 이전 행을 가져온다
        - LEAD(컬럼명, 레코드 위치차이값, NULL일 경우 대체값): 다음(특정 위치의) 행을 가져온다. default는 1이다
        - 예시
          - LAG (매장코드,2) OVER (ORDER BY 매장코드 DESC) A
            - 매장코드 기준 역순으로 배치된 테이블에서 2칸 앞의 매장코드를 칼럼 A에 배치한다
          - LEAD (매장코드, 2) OVER (PARTITION BY 지역명 ORDER BY 매장코드) B
            - 지역명에 따라 파티션을 나누고, 파티션 내에서 매장코드 순으로 정렬한다

    - ARGUMENTS: 인수(컬럼명 등 함수의 작업이 이뤄지는 대상)

    - PARTITION BY: 테이블의 레코드(행)들을 쪼개는 기준

    - ORDER BY: 쪼개진 레코드들 내에서 혹은 전체 테이블에서 레코드들을 어떤 기준으로 정렬할지

    - WINDOWING: 함수의 연산 대상이 되는 레코드의 범위를 정함

      - RANGE: 범위를 지정해줄 때 사용. RANGE BETWEEN 100 AND 399
        - Rows/Range 결과값 차이점: 같은 값 유무 파악. range는 같은 값이 나올 확률이 있다.
      - BETWEEN a AND b: a부터 b까지 윈도우가 적용됨
      - UNBOUNDED PRECEDING: 윈도우의 시작 위치 = 첫번째 행
        - SELECT 지역명, 매장코드, 매출일자, sum(매출액) OVER (PARTITION BY 매장코드 ORDER BY 매출일자 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) sum_sales WHERE EXTRACT (YEAR FROM 매출일자)=2021 ORDER BY 매출일자
      - UNBOUNDED FOLLOWING: 윈도우의 마지막 위치 = 마지막 행
      - CURRENT ROW: 윈도우 시작 위치가 현재 행

- 대량 데이터에 따른 성능 저하

  - row migration 
    - 이미 저장된 데이터에 대해 Update를 하여 행의 길이가 증가했을 때, 저장공간이 부족한 경우 발생
    - 원래 정보를 기존 블록에 남겨두고 실제 데이터는 다른 블록에 저장한다.
      - 검색 시 원래 블록에서 주소를 먼저 읽고 다른 블록을 찾아야 해서 성능 감소
    - 해결책: PCTFREE 영역을 충분히 할당 (그러나 너무 PCTFREE 영역이 큰 경우 데이터 저장 공간 부족으로 공간 효율성 감소)
  - row chaining 
    - 애초에 저장할 공간이 부족해 발생
    - 데이터가 커서 여러 블록에 나누어 저장하는 현상
      - 2개 이상의 데이터 블록을 검색해야하므로 성능 감소
    - Initial Row Piece와 Row Pointer로 블록 내에 저장
    - 해결책: DB_BLOCK_SIZE를 크게 하여 최소화 가능(그러나 사이즈 변경이 어렵고, 무조건 크게 할 수는 없다)
  - 해결할 수 있는 방법
    - 테이블 파티션: 대용량의 테이블을 여러 개의 데이터 파일에 분리하여 저장하는 것

      - 물리적으로 분리된 데이터 파일에 저장되어 입력/수정/삭제/조회 성능이 향상되고, 독립적 관리가 가능. 조회의 범위를 줄이는 효과가 있어 성능이 향상됨
      - 방식
        - RANGE PARTITION: 값의 범위를 기준으로 파티션을 나눠 저장하는 방법
          - 매출액이 5000이상인 레코드와 미만인 레코드를 별도로 저장
        - LIST PARTITION: 특정 값을 기준으로 분할
          - ex) 특정 값이 100일 때와 300일 때 각각 다른 데이터 파일에 저장
        - HASH PARTITION: 데이터베이스 관리 시스템이 자체적으로 해시함수를 사용해 분할하고 관리하는 방식
        - COMPOSITE PARTITION: RANGE PARTITION과 HASH PARTITION가 복합.

## 2과목 3장 최적화 기본원리

- 옵티마이저: SQL 실행계획을 수립하고, SQL을 실행하는 데이터베이스 관리 시스템의 소프트웨어

  - 같은 SQL문이더라도 어떻게 실행하냐에 따라 성능이 달라진다(소요시간, 자원사용량 등/결과는 같다) => SQL 문을 분석한 후 일정한 기준을 통해 실행계획을 세워줘야함. 이때 사용되는 것이 옵티마이저
  - SQL문 작성 → Parsing(문법검사, 구문 분석) → 옵티마이저(비용/규칙 기반) → 실행계획(PLAN_TABLE 저장) → SQL 실행
  - 옵티마이저는 비용기반 옵티마이저와 규칙기반 옵티마이저가 있으며 최신 Oracle은 비용기반을 default로 사용한다
    - 비용기반 옵티마이저는 시스템 통계와 오브젝트 통계를 통해 해당 SQL 문 실행에 대한 총 비용을 계산하고 <u>총 비용이 가장 적은 쪽</u>으로 실행 계획을 수립한다
      - 비용기반 옵티마이저는 인덱스 스캔이 전체 스캔보다 항상 유리하다고 판단하지는 않는다.
    - 규칙기반 옵티마이저는 <u>15가지 우선순위를 기준</u>으로 실행계획을 수립한다.
      - 가장 높은 우선순위는 ROWID를 기반으로 스캔하는 것

- 인덱스: 데이터의 색인(목자)와 동일. 원하는 데이터를 빠르게 조회할 수 있다

  - 인덱스는 인덱스 키를 기준으로 내림차순 정렬되어 있다 → 따라서 탐색이 빨라진다

  - 부정형, Life 함수, 묵시적 형변환에서 사용하지 않는다

  - 자주 변화하는 속성을 인덱스로 설정하는 것은 좋지 않음

    - 삭제 및 조회 등의 작업에 있어서 변화를 초래하지 않는 것이 좋다. 입력, 삭제, 수정 속도가 느려질 수 있다
    - DML(insert, update, delete)은 인덱스 사용 시 성능 감소
      - 목차를 만들어뒀는데 페이지를 넣거나 빼면 목차를 다시 만들어야한다. → 성능 저하

  - Primary Key는 자동적으로 index가 된다

  - <u>하나의 테이블에 여러 개의 인덱스를 생성할 수 있고, 하나의 인덱스는 여러 칼럼으로 구성될 수 있다</u>

  - 탐색 종류

    - Index Unique SCAN: 인덱스 키값이 <u>중복되지 않을</u> 때 해당 키를 통해 탐색
    - Index Range SCAN: 특정 범위를 조회하는 <u>WHERE 문</u>을 사용하여 해당 영역을 스캔. 스캔 범위에 따라 단수, 복수의 결과 혹은 0건의 결과 출력도 가능
    - Index Full SCAN: 인덱스의 <u>처음부터 끝까지 모두</u> 스캔

    + UNIQUE 속성을 가진 인덱스가 아니라면 중복 데이터 입력 가능

  - 인덱스 종류: 순차 인덱스, 비트맵, 결합인덱스, 클러스터, 해시 인덱스

  +. 인덱스를 통한 스캔은 항상 전체 테이블 스캔보다 효율적이지는 않다. <u>랜덤 엑세스</u>의 경우 많은 양의 데이터를 읽을 때 부하가 커서 오히려 전체 테이블 스캔이 유리할 수있다

  +. 파티션 테이블은 파티션 키에 대해 인덱스를 생성가능하며, 그 경우 해당 인덱스를 Global 인덱스라고 부른다

  +. 인덱스 생성이 가능한 캐릭터 타입은 VARCHAR, NUMBER, DATE, CHAR 모두 가능

- 옵티마이저 조인

  - SELECT A.* FROM table A JOIN table B ON A.id=B.id;

  - SELECT /\*ordered use_nl(B)\*/ A.* FROM table A JOIN table B ON A.id=B.id;

    *ordered use_hash, ordered use_merge

    → join을 수행하는 과정에서 성능을 최적화하기 위해 Optimizer Join  방식을 선택하여 hint(/**/)로 기입해줌

  - **종류**

    - Nested Loop Join
      - **선행테이블(외부테이블, Driving Table)**을 먼저 조회하여 연결 대상 데이터를 찾고, 그 다음 테이블을 연결함. 선행테이블 처리범위(작은게 좋음)에 따라 처리량 결정. **순차적**으로 일어남.  **RANDOM ACCESS** 발생.(적게 발생하도록 해야함)
      - **인덱스 필요**, Unique Index 시 유리. <u>온라인 트랜잭션 처리(**OLTP**)</u>에 유리. 대용량 소트 작업 시 유리
    - 선행테이블 처리 범위 많거나 랜덤 액세스 범위 많으면 sort merge join보다 불리. 
      - 중첩된 반복문과 동일한 형식. 선행테이블의 조건을 만족하는 경우의 수만큼 반복적으로 수행됨
    - Sort Merge Join
      - JOIN KEY를 기준으로 두 테이블을 각각 **정렬**하고 완료되면 병합. 
      - 데이터 양 많으면 느려짐. 정렬 대상 데이터 양이 많은 경우 **임시 디스크** 사용 → 성능 저하. 
      - **Equi JOIN, non-Equi JOIN 모두 가능**
        - Equi JOIN(등가 조인): 두 테이블 간의 컬럼 값들을 조인하는 조건이 '='인 경우. PK, FK 관계를 기반
        - non-Equi JOIN(비등가 조인): 조인 조건으로 BETWEEN, >, < 등 =이 아닌 연산자를 사용하여 조인하는 경우
    - Hash Join
      - 두 테이블 중 <u>작은 테이블</u>을 **Hash** 메모리에 로딩. 두 테이블의 조인 키를 사용하여 해시 테이블을 생성함. 두 테이블 동시 스캔. 선행테이블에는 작은 테이블 먼저 와야함. 
      - Hash 처리를 하므로 별도 저장공간 필요 (은근 데이터 잡아먹는다). **시스템 자원**을 최대한 활용 가능.(너무 많이 사용될 우려 있다)
      - **EQUI JOIN에서만 가능**, <u>인덱스를 사용하지 않음</u>. 함수 처리함
    
    +. Join은 순차적으로 아무리 많아도 2개씩 작업. 테이블과 테이블 사이, 앞에서 이미 수행된 조인 결과 집합과 테이블, 조인 결과와 조인 결과 사이에서 발생

- PL/SQL: SQL을 확장시켜 다양한 절차적 프로그래밍을 가능하게 한 언어

  - Block 구조. 기능별 모듈화
  - Declare 문으로 변, 상수 선언하며 시작
    - DECLARE, BEGIN~END는 필수. EXCEPTION 생략 가능
  - DML, IF, LOOP 등 다양한 절차적 언어 사용
  - Procedure, User Defined Function, Trigger 객체 작성 가능
    - Procedure 내부에 작성된 절차적 코드는 PL/SQL 엔진이 처리, 일반적 SQL 문장은 SQL 실행기가 처리
    - 셋의 차이점
      - Procedure는 반드시 값이 나오지 않는다
      - Trigger는 COMMIT, ROLLBACK 불가. DML 많이 쓴다
      - User Defined Function는 반드시 값이 나온다
  - 오라클에 내장되어 있음 동일한 언어를 사용하는 프로그램과 호환 가능
  - 응용 프로그램의 성능을 향상시킴

- 분산 데이터베이스: 하나의 데이터베이스 시스템(DBMS)이 네트워크를 통해 물리적으로 분리된 데이터베이스들을 제어하는 형태의 DB

  - 성능향상. / 신뢰성 높다 / 모듈화 
  - 분산 데이터베이스 추가를 통한 용량 확장, 중요 데이터 보호 용이
  - 관리와 통제, 보안관리, 무결성 통제 어렵고 복잡한 구조

- 실행 계획
  - 순서

    - 들여쓰기 할수록 먼저 실행된다. 가장 마지막에 시행되는 것을 마지막으로 둔다. 그 후 같은 레벨인 경우 묶음으로 처리한다. 묶음 간의 우열은 들여쓰기가 얼마나 되어있는지로 따진다.

    - 예시

      ```
      1┙
      2 	┙
      3		┙
      4	┙
      5		┙
      ```

      - (3-2)-(5-4)-1