# SQLD

## [최종 정리강의](https://www.youtube.com/channel/UCosmeBx3OuKP1YwGmT6ar2Q)

- SQL 연산 순서

  - from - where - group by - having - select - orderby

- 종류

  - DML: select, insert, delete, update
  - DDL: alter, create, modify, drop
  - DCL: grant, revoke
  - TCL: rollback, commit

- select

  - distinct
    - 중복된 값들이 존재할 때 원하는 정보를 집약시켜주는 기능
    - Distinct deptno, mgr
      - 사실상 Distinct (deptno, mgr) 이것과 같은 의미. deptno와 mgr에 대해 distinct가 들어가는 것. group by (deptno, mgr)과 비슷하다.
  - as
    - select절에서의 as
      1. as 생략 가능
      2. column명에 띄어쓰기가 있는 경우
         - ex. "직원 번호"
    - from절에서의 as
      1. as 사용 불가
  - concat 함수: 인수가 반드시 2개여야 한다. 
    - +: SQL server
    - ||: oracle

- 논리연산자

  - 종류

    - and: A와 B를 모두 만족
    - or: 하나 이상의 조건이 만족
    - not: 조건을 부정

  - 연산순위

    1. not
    2. and
    3. or

    ex. not <조건1> and <조건2> and not <조건3> or <조건4>

    ​		: 조건1과 조건3을 부정한다. 그 후 and를 계산하고 or을 계산한다.

- sql 연산자

  - between and

    - A between 1 and 2: A가 1이상 2이하인 것

  - in

    - A in (1,2,3): A는 1이거나 A는 2이거나 A는 3

  - **like**

    - 와일드 카드

      - _: 미지의 한 글자
      - %: 0 이상의 글자

      ex. _L%: 두번째 글자가 L인 것

    - escape

      - 와일드카드인 _와 %를 문자로 취급해주는 함수

      ex. name like 'A@_A' escape '@': _를 문자로 취급하게 된다.

      ex. name like '%#%%' escape '#': 문자 %를 포함한 것을 찾는다.

  - Rownum (oracle)

    - where 조건절에서 Rownum이 1인 경우 포함
      - Rownum은 적층구조. 범위형태로 주어야 한다. 

    ex. select from empno, cell where rownum<=3 order by sal desc

    - order by sal이 가장 마지막에 시행된다. 따라서 정렬 전에 rownum에 의한 조건절이 시행된다. 따라서 rownum이 3이하인 것을 뽑고 난 후에 그 행에 대해 내림차순으로 정렬된 것이 출력된다.

  - Top (sqlserver)

    - Top (n) <컬럼명>: select 절에서 컬럼명을 출력할 때 상위 n개의 행을 가져온다.

- **null**

  - 정의: 부재. 모르는 값.

  - 산술 연산

    - null + 2 -> null
    - null - 4 -> null
    - null x null -> null

  - 비교 연산

    - null = null -> 알 수 없음(unknown)
    - null = 2 -> 알 수 없음(unknown)

    where 조건절에 unknown이 들어오면 False라고 판단함

  - 정렬 상 의미

    - oracle에서는 ∞의 의미
    - sql server에서는 최소의 값. -∞

  - 함수

    - nvl(값1, 값2): 값1이 null이라면 값2, null이 아니라면 값1.
    - nvl2(값1, 값2, 값3): 값1이 null이면 값3. null이 아니라면 값2
    - isNull(값1, 값2): 값1이 null이라면 값2, null이 아니라면 값1.
    - nullif(값1, 값2): 2개의 값이 같으면 null 다르면 값1
    - coalesce(값1, 값2, ...): null 아닌 첫번째 값

- 정렬

  - 특성

    1. <u>가장 마지막에 실행</u>
    2. 쿼리문을 돌릴 때 성능이 느려질 가능성이 있다. 
    3. null값과의 관계
       - oracle에서는 ∞로, sql server에서는 -∞로 취급된다

  - 컬럼 번호 정렬

    - 출력되는 컬럼의 수보다 큰 값이 <u>허용되지 않는다.</u>

    - 출력되지 않는 컬럼명으로 정렬 가능하다.

      ex. select name order by sal

  - 인수 2개의 정렬

    ex. sal desc, name asc: sal이 같은 경우 name 오름차순으로 정렬

- 숫자 함수

  - round: 반올림

    ex. round(138.94) -> 139	// 두번째 파라미터의 값이 0이라서 생략되어있다.

    ​	  round(123.57, 1) ->123.6 

  - ceil(oracle) / ceiling(sql server): 올림함수. round와 같이 두번째 파라미터는 어느 자리에서 연산할지.

- 문자열 함수

  - upper(문자열): 대문자로 변환
  - lower(문자열): 소문자로 변환
  - lpad(값, 총 문자길이, 채움문자): 지정한 길이만큼 왼쪽부터 특정 문자로 채워줌
    - 채움문자를 지정하지 않으면 공백으로 해당길이만큼 문자를 채운다
  - rpad(값, 총 문자길이, 채움문자): 지정한 길이만큼 오른쪽부터 특정 문자로 채워줌
    - 채움문자를 지정하지 않으면 공백으로 해당길이만큼 문자를 채운다
  - trim(문자열): 문자열의 양쪽 공백을 제거
  - ltrim(문자열, 제거할 문자열): 문자 왼쪽의 반복적인 문자를 제거를 한다. 
    - 옵션을 쓰지 않았을 때: 문자열의 왼쪽 공백 제거
  - rtrim(문자열, 제거할 문자열): 문자 오른쪽의 반복적인 문자를 제거를 한다. 
    - 옵션을 쓰지 않았을 때: 문자열의 오른쪽 공백 제거
  - substr(문자열, 시작위치, 길이): 문자열을 자른다.
    - 길이를 쓰지 않으면 끝까지. 위치는 맨 첫글자부터 1이다.
  - instr(문자열, 찾을 문자열, 시작 위치, 발생횟수): 문자열에서 찾고자 하는 문자열과 일치하는 위치를 반환
    - 시작위치와 발생횟수의 디폴트 값은 1이다.
  - replace(문자열 혹은 열 이름, 바꾸려는 문자열, 바뀔 문자열): 특정 문자열을 찾아 바꾸는 함수

- 날짜함수

  - to_char: 날짜, 숫자 등의 값을 문자열로 변환하는 함수. 데이터의 형변환을 일으키는 함수
  - to_date: 날짜 데이터 타입으로 변화해 주는 함수. 데이터의 형변환을 일으키는 함수
  - sysdate: 오라클에서 현재 시간을 출력해주는 함수
  - getdate: sql server에서 현재 시간을 출력해주는 함수

  날짜 데이터 + 100 -> 100일 이후. day로 인식한다.

- decode/case

  - decode: if와 비슷하다.

    ```sql
    decode(A, 1, 'a',   -- null은 생략 가능
              2, 'b',   
              3, 'c',   
                ,'d')  
    --A가 1이면 a, 2이면 b, 3이면 c, 이외에는 d를 출력  
    ```

  - case

    ```sql
    case 조건 when 결과1 then 출력1
    		 [when 결과2 then 출력2]	
    else 출력3	--else가 없는 경우 조건1, 조건2 만족하지 않을 때 null이 출력된다.
    end 컬럼명
    ```

- **집계함수**

  - null과의 관계

    - | A    | B    | C    |
      | ---- | ---- | ---- |
      | null | null | 1    |
      | 3    | 2    | 2    |
      | null | 2    | 3    |

      sum(A) = 3			sum(B) = 4		

      count(A) = 1		 count(*) = 3

      sum(A+B+C) = 7: 새로운 column을 만들고 풀어라. (A+B+C는 null 7 null로 나온다.)

      * sum(A+B+C)와 sum(A) + sum(B) + sum(C)는 다르다

- <u>pivot/unpivot</u> 함수

  - pivot: SELECT 필드목록 FROM 테이블 PIVOT(집계함수 FOR 대상필드 IN (필드값 목록)) 
    - 행으로 나열되어있는 데이터를 열로 나열하여 보기 쉽게 가공함. 대상 필드의 값 목록을 새로운 열로 만들고 각 열에 대해 집계 함수를 호출하여 결과셋을 만든다.
  - unpivot: SELECT 가져올\_컬럼명, 데이터를\_재구축할\_컬럼명 FROM 테이블 UNPIVOT (검색할_열 FOR 대상칼럼 IN (언피봇 대상 컬럼 목록))
    - 피봇의 반대 동작을 수행(피봇과 완전한 반대 연산자는 아니다)

- group by

  - 집약기능이 있다.
  - 그룹 수준으로 정보를 바꾼다.
  - having도 그룹에 대한 조건식이다.

- join

  - natural join using
    - 중복된 컬럼이 사라진다. 제일 앞에 등장하는 것 하나만 출력됨.  
    - using의 경우 alias 사용 가능
  - left outer join
    - 'A left outer join B' = 'A col1 = B col1 (+)'
      - 이 때 col1이 조인키이다.
      - A, B 순서 같고 left라서 (+)가 오른쪽에 붙는다

  - join하면 할수록 column이 늘어난다.

  - 조인 순서
    - from A, B, C: A, B 조인한 후 하나의 테이블이 되었을 때 C와 조인한다.
  
- 서브 쿼리

  - select: scalar(단일 행 서브쿼리)
  - from: inline view(메인쿼리에 컬럼 사용 가능하다)
  - where: 거의 모든 서브쿼리(중첩서브쿼리)
  - group by: 서브쿼리가 들어가지 않는다
  - having: 거의 모든 서브쿼리(중첩서브쿼리)
  - order by: scalar
  - 상호연관 서브쿼리가 있을 때 select from A where (select from B...)
    - A 테이블 row를 하나 볼 때 전체 테이블 B를 본다. 
  - 함수
    - in
    - any/some
    - all
    - exist: 모든 문자 사용 가능. 존재하면 True, 0 rows인 경우 False

- 집합 연산자

  - union: 중복을 제거한 합집합
  - intersect: 교집합
  - minus
    - 차집합
    - sql 서버에서는 except라고 한다
  - unionall
    - 중복 데이터 존재. 정렬 작업이 없고 빠르다(나머지 셋은 정렬 작업 존재 -> 느림)

- DDL

  - TCL과 연관지어서 생각하기
  - Truncate(입주민 퇴거. 구조 남음. log data 남음) vs Drop(건물 철거. 구조 삭제)
  - Truncate(DDL) vs Delete(DML)

- DML

  - TCL과 연관지어서 생각하기
  - insert: 지정한 매개변수와 value의 개수가 다를 때 -> 오류상황
  - update
  - delete
  - <u>merge</u> -> 37회 기출 참고

- **제약조건**

  - pk: unique + notnull. 대표성 가지므로 하나만 있다
  - unique: 고유한 값
  - notnull

- DCL

  - grant: 사용자(User)에게 접속권한, 오브젝트 생성권한, DBA 권한 등을 부여할 수 있는 명령어
  - revoke: 사용자(User)에게 부여한 권한을 다시 회수하는 명령어 
  - role 특징(role의 type은 object이다)
    - role을 사용하면 권한 부여와 회수를 쉽게 할 수 있다
    - 한 사용자가 여러 Role을 access할 수 있고, 여러 사용자에게 같은 Role을 부여할 수 있다
    - 사용자는 Role에 Role을 부여할 수도 있다
  - 37회 기출문제 on to

- view

  - sql 명령문 저장. 기존 테이블보다 저장 공간이 적게 필요함
  - **장점**
    - 독립성: 기존 table 구조가 변경되어도 view의 구조는 변경되지 않는다. view를 따로 업데이트하지 않아도 된다.
    - 편리성: 계속 테이블을 조작할 필요는 없다
    - 보안성: 원하는 정보만 가져올 수 있다

- **그룹함수**

  - 종류
    - rollup: subtotal 생성. n+1개 subtotal 생성. 인수가 2개가 다른 순서로 들어오면 다른 결과가 나온다.
      - rollup(A,B) != rollup(B,A) 계층구조로 진행되기 떄문이다.
    - cube: 결합 가능한 모든 값에 대해 다차원 집계를 생성. 2^n
      - cube(A,B) == cube(B,A)
    - groupingsets: 인수들에 대한 개별 집계를 구할 수 있다
    - grouping: 집계 표시이면 1, 아니라면 0
  - 어떤 그룹함수를 썼는지 찾는 문제가 나왔을 때
    1. null을 모두 찾는다
    2. 총합 행이 있는지 찾는다.
       1. 있다면?
          - rollup: 한 쪽만 결과가 나오며 계층형태 가진다. 행의 수 적음
          - cube: 양 쪽으로 둘 다 결과가 나옴. 행의 수 많음
       2. 없다면?
          - groupingsets

- TCL

  - 종류
    - commit
    - rollback
  - DDL의 커밋 기능 없애기
    - auto commit off and Begin transaction

- **윈도우 함수**

  - Rows/Range 결과값 차이점
    - 같은 값 유무 파악. range는 같은 값이 나올 확률이 있다.
  - rank/dense rank
    - rank는 중복건너뛴다.(후순위 건너뜀) 1,1,3,4등
    - dense rank는 건너뛰기 없음. 1,1,2,3등
  - partition by/order by 의미

- 계층형 질의

  - **prior 자식데이터 = 부모데이터**
    - prior은 연산자
    - 예시
      - level1 KING empno
        level 2 James mgr
        level 3 Scott
        -> 현재 James의 mgr이 KING의 empno이다.
        -> level2의 입장에서 prior 값은 level1.
        => **prior empno = mgr**
  - **부모 데이터에서 자식으로 가는 경우: 순방향**
  
- 절차형 PL/SQL

  - <u>Exception 생략 가능</u>
  - Procedure vs trigger vs userdefined function
    - Procedure는 반드시 값이 나오지 않는다
    - trigger는 commit, rollback 불가. DML 많이 쓴다
    - userdefined function는 반드시 값이 나온다

- 데이터모델링

  - 복잡한 현실세계(업무)를 데이터 모델화시킨다.
  - [참고]소프트웨어 개발 방법론
    1. 데이터 구조화론: 업무에만 집중한다. 절차도에 따른 프로그래밍
       	ex. 책 판다 - 돈 받는다 - 매출 상승.
    2. <u>관계형 데이터베이스</u>: 데이터 자체와 관계에 집중. 핵심적 정보를 연결지어 유기체적으로 모든 업무를 포괄할 수 있도록 함
       	ex. 프로세스가 다른 업무들도 진행하면 정보를 따로 쓰게된다. data 중복 & data quality  감소 -> 관계형 데이터 베이스 도입
    3. ~~객체지향 데이터베이스~~

- 엔티티

  - 업무 상 관리하고자하는 대상
  - 특징
    - 속성을 2개 이상 가져야 함
    - 관계는 1개 이상 가져야 한다
    - 업무에서 사용되어야 한다.  업무 프로세스에 이용되어야 한다
  - 분류
    - 유무형에 따른 분류
      - 유형: 물리적 형태			ex. 사원, 물품
      - 개념: 개념적 정보			ex. 조직, 상품
      - 사건: 업무 수행 시 발생  ex. 주문, 미납
    - 발생시점에 따른 분류
      - 기본: 업무에 원래 존재하는 정보.				ex. 사원, 부서
      - 중심: 기본 엔티티로부터 발생				      ex. 계약, 주문
      - 행위: 2개 이상의 부모 엔티티로부터 발생  ex. 주문 목록

- 속성

  - 관리하고자하는 대상인 인스턴스의 집합
  - 분류
    - 기본: 업무로부터 추출한 모든 일반적인 속성
    - 설계: 업무를 규칙화하기 위해 새로 만들거나 변형    ex. 일련번호
    - 파생: 다른 속성에 영향을 받아 발생하는 속성            ex. 합

- 도메인

  - 지정해줄 수 있는 것: 유형, 크기, 제약조건
  - 물리적 데이터 모델링 - check, primary key 등이 도메인에 해당
  
- 관계

  - IE 표기법
    - 표처럼 생김. 맨 위에는 pk를 써주고 나머지 일반 속성들은 그 아래에 써준다
    - 필수관계는 |, 선택관계는 o|로 표기한다.(상대 쪽에 표기함)
  - Barker 표기법
    - 둥근 박스를 쓰고, 식별자는 #, 나머지는 o으로 표기한다
    - 필수관계는 실선, 선택관계는 점선으로 표기(자신에게 표기)

- 식별자

  - 식별자/비식별자 관계

    |                        | 식별                                          | 비식별                           |
    | ---------------------- | --------------------------------------------- | -------------------------------- |
    | **관계**               | 강한 관계                                     | 약한 관계                        |
    | **단점**               | SQL 구분이 복잡해짐                           | 느리다.                          |
    | 단점 이유              | PK가 계속 상속해서 내려가므로 PK 속성 수 증가 | 불필요한 조인 관계가 많이 생겨서 |
    | 표기(ERD. IE에만 존재) | 실선                                          | 점선                             |

  - ERD 서술 특징

    - 시선 때문에 좌상 -> 우하로 움직여야 한다
    - 관계명 반드시 표기하지 않아도 된다
    - UML은 객체지향에서만 사용된다

  - 주식별자의 특징

    - 유일성: 인스턴스를 유일하게 구분
    - 최소성: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
    - 불변성: 지정된 주식별자의 값은 자주 변하지 않아야 함 (변하면 이전 기록 말소됨)
    - 존재성: NOT NULL 조건. 

    다 만족하면 후보키, 대표로 선정된 것이 PK이다. 
    PK + 대체키 = 후보키
  
- 성능 데이터 모델링

  - 방법
    - 아키텍처 모델링 수정: 데이터 베이스 구조를 바꾼다 -> 더 성능이 좋고 효과적이다
      - 아키텍처: 테이블, 파티션
      - 테이블 분할, 파티션 분할 등
    - SQL 명령문 수정
      - 조인수행 원리
      - 해시 조인
      - 옵티마이저
      - 실행계획

- **<u>정규화</u>**

  - 정규화 수행 방법 및 예시
    - 제 1 정규화: 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블 분해
    - 제 2 정규화: 완전 함수 종속을 만족하도록 테이블 분해(PK의 부분집합이 결정자가 되지 않도록)
    - 제 3 정규화: 이행적 종속(A -> B, B -> C가 성립할 때 A -> C가 성립되는 것)을 없애도록 테이블 분해
    - BCNF 정규화: 모든 결정자가 후보키가 되도록 테이블 분해
    - 제 4 정규화: 다치 종속 제거
    - 제 5 정규화: 조인 종속 제거
  - 이상현상 
    - 삭제 이상: 한 튜플을 삭제할 때 연쇄 삭제 -> 정보 손실 
    - 삽입 이상: 데이터 삽입 시 원하지 않는 값도 같이 삽입됨
    - 갱신 이상: 튜플의 속성값을 갱신할 때 일부 튜플의 정보만 갱신됨 -> 정보의 모순
  - 성능 
    - select에서는 join 때문에 느려질 수 있다
    - Insert update는 성능 증가(테이블이 작아지기 때문)

  정규화는 성능 모델링 전에 한 후에 시작해야한다

- 반정규화

  - **데이터 무결성을 해칠 수 있다**
  - 과정
    1. 대상 분석
       - 대량 범위 처리 빈도수 조사
       - 범위 처리 빈도수 조사
       - 통계 처리 여부 조사
    2. 통계처리 필요하다면 다른 방법을 검토한다
       - 응용 시스템 변경
       - 클러스터링/인덱스 처리
       - 뷰 테이블 처리
    3. 2번 방법들이 통하지 않는다면 반정규화 진행
       - 테이블 반정규화
         - 병합
           - 1:1, 1:M, 슈퍼/서브타입 병합
         - 분할
           - 수직/수평 분할
       - 속성 반정규화(정의/기법)
         - 파생 컬럼 추가
         - 응용 시스템 오작동을 위한 칼럼 추가
         - 이력 테이블 컬럼 추가
         - pk에 의한 칼럼 추가: pk를 일반속성으로 편입
         - 이력 테이블 칼럼 추가
       - 관계 반정규화
         - 중복 관계 추가

- 대량 데이터에 따른 성능

  - row migration 
    - 이미 저장된 데이터에 대해 Update를 하여 행의 길이가 증가했을 때, 저장공간이 부족한 경우 발생
    - 원래 정보를 기존 블록에 남겨두고 실제 데이터는 다른 블록에 저장한다.
      - 검색 시 원래 블록에서 주소를 먼저 읽고 다른 블록을 찾아야 해서 성능 감소
    - 해결책: PCTFREE 영역을 충분히 할당 (그러나 너무 PCTFREE 영역이 큰 경우 데이터 저장 공간 부족으로 공간 효율성 감소)
  - row chaining 
    - 애초에 저장할 공간이 부족해 발생
    - 데이터가 커서 여러 블록에 나누어 저장하는 현상
      - 2개 이상의 데이터 블록을 검색해야하므로 성능 감소
    - Initial Row Piece와 Row Pointer로 블록 내에 저장
    - 해결책: DB_BLOCK_SIZE를 크게 하여 최소화 가능(그러나 사이즈 변경이 어렵고, 무조건 크게 할 수는 없다)
  - 해결할 수 있는 방법
    - List Partition: 특정 값에 따라 분리 저장
      - 보관주기에 따라 테이블의 데이터 지우기는 불가능
    - Range Partition: 범위, 날짜, 숫자값으로 테이블 분할
      - 데이터 보관주기에 따라 테이블의 데이터 지우기 가능
      - 관리가 쉽고 가장 많이 쓰인다
    - Hash Partition
      - Hashing 알고리즘이 적용되어 테이블 분리. 설계자는 테이블에 데이터가 어떻게 들어갔는지 알 수 없다
      - 관리가 어렵다
    - Composite Partition
      - range와 hash가 복합.

- 슈퍼/서브타입

  - 용량별로 처리가 가능
    - 적은 경우에는 one to one 테이블 사용
      - 트랜잭션이 개별로 들어간다
    - 큰 경우 바로 트랜잭션 유형으로 분류
  - 트랜잭션 유형에 따라서 
    - 공통/차이점에 따라서 별개로 트랜잭션 들어간다
      - 슈퍼 서브 타입이라는 크로스타입을 사용함
    - 전체 테이블 통합으로 트랜잭션이 들어감(싱글 타입_하나의 통합된 테이블)

- 분산 데이터 베이스

  - 데이터 베이스를 여러 개의 서버로 뜯어놓는것(반정규화와 유사)

    -> 데이터 무결성을 해침	

- <u>**조인 수행 원리**</u>

  - NL join
    - 랜덤 액세스
    - 대용량 소트 작업 시 유리함
  - Sort merge
    - join key를 기준으로 정렬
    - **등가/비등가 조인** 
      - 등가 조인: 두 테이블 간의 컬럼 값들을 조인하는 조건이 '='인 경우. PK, FK 관계를 기반
      - 비등가 조인: 조인 조건으로 BETWEEN, >, < 등 =이 아닌 연산자를 사용하여 조인하는 경우
  - Hash join
    - 등가 조인만 사용함
    - 함수처리함
    - 선행 table 작다
    - Hash 처리를 하므로 별도 저장공간 필요 (은근 데이터 잡아먹는다)

- 옵티마이저

  - CBO(Cost Based Optimizer)
    - 경로를 짜보았을 때 가장 저렴한 것(경제적인 것)을 선택
  - RBO(Rule Based Optimizer)
    - 규칙에 따라 옵티마이징 이루어짐

- 인덱스

  - 부정형, Life 함수, 묵시적 형변환에서 사용하지 않는다
  - DML(insert, update, delete)은 인덱스 사용 시 성능 감소
    - 목차를 만들어뒀는데 페이지를 넣거나 빼면 목차를 다시 만들어야한다. -> 성능 저하

- 실행 계획

  - 순서

    - 들여쓰기 할수록 먼저 실행된다. 가장 마지막에 시행되는 것을 마지막으로 둔다. 그 후 같은 레벨인 경우 묶음으로 처리한다. 묶음 간의 우열은 들여쓰기가 얼마나 되어있는지로 따진다.

    - 예시

      ```
      1┙
      2 	┙
      3		┙
      4	┙
      5		┙
      ```

      - (3-2)-(5-4)-1
      
      

## 노랭이 핵심정리

### 1과목 1장: 데이터 모델링의 이해

- 발생시점에 따른 엔터티 분류
  - 기본/키엔터티
  - 중심엔터티
  - 행위엔터티
  
- 데이터모델링
  - 데이터모델링이란?
    - 정보시스템을 구축하기 위한 데이터 관점의 업무 분석 기법
    - 현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정
    - 데이터베이스를 구축하기 위한 분석/설계의 과정
  - 데이터 모델링 유의점
    - 중복
    - 비유연성
    - 비일관성
  - 종류
    - 개념적 데이터 모델링: 추상화 수준이 높고 업무중심적이고 포괄적인 수준의 모델링 진행. 전사적 데이터 모델링, EA 수립 시 많이 사용
    - 논리적 데이터 모델링: 시스템으로 구축하고자하는 업무에 대해 Key, 속성, 관계 등을 정확하게 표현, 재사용성이 높음
    - 물리적 데이터 모델링: 실제로 데이터베이스에 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계
  
- 데이터베이스 스키마 구조 3단계
  - 외부 스키마
  - 개념 스키마
  - 내부 스키마
  
- ERD 작성 순서
  1. 엔터티를 그린다
  2. 엔터티를 적절하게 배치한다
  3. 엔터티간 관계를 설정한다
  4. 관계명을 기술한다
  5. 관계의 참여도를 기술한다
  6. 관계의 필수여부를 기술한다
  
- 엔터티의 특징
  - 반드시 해당 업무에서 필요하고 관리하고자하는 정보이어야 한다
  - 유일한 식별자에 의해 식별이 가능해야 한다
  - 영속적으로 존재하는 인스턴스의 집합이어야 한다(두 개 이상)
  - 엔터티는 업무 프로세스에 의해 이용되어야 한다
  - 엔터티는 반드시 속성이 있어야 한다
  - 엔터티는 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다
  
- 엔터티, 인스턴스, 속성, 속성값의 관계
  - 한 개의 엔터티는 두 개 이상의 인스턴스의 집합이어야 한다
  - 한 개의 엔터티는 두 개 이상의 속성을 갖는다
  - 한 개의 속성은 한 개의 속성 값을 갖는다
  
- 속성의 특성에 따른 분류
  - 기본속성
  - 설계속성
  - 파생속성
  
- 각 속성은 가질 수 있는 값의 범위가 있는데 이를 그 속성의 도메인이라 하며, 엔터티 내에서 속성에 대한 데이터타입과 크기 그리고 제약사항을 지정하는 것이다

- 속성의 명칭 부여
  - 해당업무에서 사용하는 이름을 부여한다
  - 서술식 속성명은 사용하지 않는다
  - 약어사용은 가급적 제한한다
  - 전체 데이터모델에서 유일성 확보하는 것이 좋다

- ERD에서는 존재적 관계와 행위에 의한 관계를 구분하지 않지만 클래스 다이어그램에서는 이것을 구분하여 연관관계와 의존 관계로 표현한다

- 관계의 표기법

  - 관계명: 관계의 이름
  - 관계차수(Cardinality): 1:1, 1:M, M:N
  - 관계선택사양: 필수관계, 선택관계

- 관계 읽기

  - 기준 엔터티를 한 개 또는 각으로 읽는다
  - 대상 엔터티의 관계참여도, 즉 개수를 읽는다.
  - 관계선택사양과 관계명을 읽는다.

- 식별자와 비식별자관게 비교

  | 항목               | 식별자관계                                                   | 비식별자관계                                                 |
  | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | 목적               | 강한 연결관계 표현                                           | 약한 연결관계 표현                                           |
  | 자식 주식별자 영향 | 자식 주식별자의 구성에 포함됨                                | 자식 일반 속성에 포함됨                                      |
  | 표기법             | 실선 표현                                                    | 점선 표현                                                    |
  | 연결 고려사항      | - 반드시 부모엔터티 종속<br />- 자식 주식별자 구성에 부모 주식별자 포함 필요<br />- 상속받은 주식별자속성을 타엔터티에 이전 필요 | - 약한 종속관계<br />- 자식 주식별자 구성을 독립적으로 구성<br />- 자식 주식별자구성에 부모 주식별자 부분 필요<br />- 상속받은 주식별자속성을 타 엔터티에 차단 필요<br />- 부모 쪽의 관계 참여가 선택관계 |

- 식별자의 종류

  - 엔터티 내에서 **대표성**을 가지는가에 따라 <u>주식별자와 보조식별자</u>로 구분
    - 주식별자: 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이며, 타 엔터티와 참조관계를 연결할 수 있는 식별자
      - 주식별자의 특징
        - 유일성: 주식별자에 의해 엔터티 내에 모든 인스턴스들을 유일하게 구분함
        - 최소성: 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 함
        - 불변성: 주식별자가 한 번 특정 엔터티에 지정되면 그 식별자의 값은 변하지 않아야 함
        - 존재성: 주식별자가 지정되면 반드시 데이터 값이 존재(NOT NULL)
    - 보조식별자: 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계 연결을 못함
  - 엔터티 내에서 **스스로 생성**되었는지 여부에 따라 <u>내부식별자와 외부식별자</u>로 구분
    - 내부식별자: 엔터티 내부에서 스스로 만들어지는 식별자
    - 외부식별자: 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자
  - **단일 속성으로 식별**이 되는가에 따라 <u>단일식별자와 복합식별자</u>로 구분
    - 단일식별자: 하나의 속성으로 구성된 식별자
    - 복합식별자: 둘 이상의 속성으로 구성된 식별자
  - 원래 업무적으로 의미가 있던 식별자 속성을 대체하여 일련번호와 같이 **새롭게 만든 식별자**를 구분하기 위해 <u>본질식별자와 인조식별자</u>로 구분
    - 본질식별자: 업무에 의해 만들어지는 식별자
    - 인조식별자: 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자

### 1과목 2장: 데이터 모델과 성능

- 성능데이터 모델링이란?
  - 데이터베이스 성능 향상을 목적으로 설계단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것이다
- 중복속성에 대한 분리가 1차 정규화의 대상이 되며, 로우단위의 중복도 1차 정규화의 대상이 되지만 칼럼 단위로 중복이 되는 경우도 1차 정규화의 대상이다
- 반정규화
  - 반정규화란
    - 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다
    - 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있고 좀 더 넓은 의미의 반정규화는 데이터를 중복하여 성능을 향상시키기 위한 기법이라고 정의할 수 있고 좀 더 넓은 의미의 반정규화는 성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미한다
    - 데이터 무결성이 깨질 수 있는 위험을 무릅쓰고 데이터를 중복하여 반정규화를 적용하는 이유는 데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되거나 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나 칼럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 반정규화를 수행하게 된다
  - 절차
    1. 반정규화 대상조사
       - 범위처리빈도수 조사
       - 대량의 범위 처리 조사
       - 통계성 프로세스 조사
       - 테이블 조인 개수
    2. 다른 방법유도 검토
       - 뷰 테이블
       - 클러스터링 적용
       - 인덱스의 조정
       - 응용애플리케이션
    3. 반정규화 적용
       - 테이블 반정규화
       - 속성의 반정규화
       - 관계의 반정규화
  - 반정규화의 대상에 대해 다른 방법으로 처리
    - 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰를 사용하면 이를 해결할 수도 있다
    - 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우에 클러스터링을 적용하거나 인덱스를 조정함으로써 성능을 향상시킬 수 있다
    - 대량의 데이터는 PK의 성격에 따라 부분적인 테이블로 분리할 수 있다. 즉 파티셔닝 기법이 적용되어 성능저하를 방지할 수 있다
    - 응용 애플리케이션에서 로직을 구사하는 방법을 변경함으로써 성능을 향상시킬 수 있다
- 슈퍼/서브 타입 데이터 모델의 변환기술
  - 개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
  - 슈퍼타입 + 서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
  - 전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성
- pk순서를 결정하는 기준은 인덱스 정렬구조를 이해한 상태에서 인덱스를 효율적으로 이용할 수 있도록 pk순서를 지정해야한다. 즉 인덱스의 특징은 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다. 앞쪽에 위치한 속성 값이 가급적 '=' 아니면 최소한 범위 'BETWEEN' '<>'가 들어와야 인덱스를 이용할 수 있는 것이다.
- 분산 데이터베이스 장단점
  - 장점
    - 지역 자치성, 정증적 시스템 용량 확장
    - 신뢰성과 가용성
    - 효용성과 융통성
    - 빠른 응답 속도와 통신비용 절감
    - 데이터의 가용성과 신뢰성 증가
    - 시스템 규모의 적절한 조적
    - 각 지역 사용자의 요구 수용 증대
  - 단점
    - 소프트웨어 개발 비용
    - 오류의 잠재성 증대
    - 처리 비용의 증대
    - 설계, 관리의 복잡성과 비용
    - 불규칙한 응답 속도
    - 통제의 어려움
    - 데이터 무결성에 대한 위협

### 2과목 1장 SQL 기본 

- SQL 문장 종류

  - DCL: 데이터베이스 사용자에게 권한을 부여/회수하는 언어

    - GRANT: 권한 부여
      - GRANT 권한 ON 테이블 TO 유저;
    - REVOKE: 권한 회수
      - REVOKE 권한 ON 테이블 FROM 유저;
    - 권한의 종류: SELECT,INSERT,UPDATE,DELETE / REFERENCES,ALTER,INDEX / ALL
      - WHERE 조건문을 사용가능하게 하려면 SELECT 권한 부여해야 한다
      - ROLE이란? 
        - 다양한 권한을 다양한 유저를 대상으로 관리하기 위한 명령어. 
        - 다양한 권한을 하나의 그룹으로 묶어서 관리할 수 있도록 하는 논리적인 권한의 그룹. 
        - 여러 사용자에게 동일한 ROLL 부여 가능하다. 
        - ROLE의 생성은 CREATE ROLE 권한을 가진 유저가 할 수 있다.
    - GRANT 옵션
      - TO 유저 WITH GRANT OPTION;
        - 특정 사용자에게 권한 부여 가능한 권한 부여
        - 엄마가 회수될 때 자식도 회수됨
      - TO 유저 WITH ADMIN OPTION;
        - 테이블에 대한 모든 권한 부여
        - 엄마의 권한 회수는 나와 상관이 없다

  - DDL: 데이터를 보관하고 관리하기 위한 객체의 구조를 정의하기 위한 언어. SQL 서버에서 자동으로 DB에 반영

    - CREATE: 데이터베이스 상 테이블 구조 생성

      ```sql
      CREATE TABLE C_INFO (		 --테이블 이름 C_INFO
          이름		varchar2(10),	--컬럼명과 컬럼의 속성 정의
          생년		number(4) default 9999,
          phone	 varchar2(15) not null,
          첫방문일   date,
          고객번호   varchar2(10) primary key
      );	
      ```

      - 구조

        - 컬럼명의 시작은 무조건 문자로. 영어, 한글, 숫자 모두 가능

          +) 테이블명의 시작은 무조건 문자로. 영어, 숫자, _, #, $ 모두 가능
          		다른 테이블명과 중복되지 않아야하고, 칼럼 뒤 데이터 유형은 꼭 지정되어야 함

        - 데이터 타입

          - number: 숫자형
          - date: 날짜형
          - varchar2: 가변길이 문자열
            - '호호' != '호호   '
          - char: 고정된 크기 문자열 할당된 길이만큼 문자를 채움
            - '호호' = '호호   '

      - 제약조건(CONSTRAINT)

        - default: 기본값 지정
        - not null: null 입력 불가
          - null: 모르는 값. 값이 없음(부재)을 의미. null과의 모든 비교 및 연산은 null값을 반환하며, NULL **IS** NULL = TRUE. NULL은 숫자0이나 공백문자와 동일하지 않음.
          - count(*): 전체 행의 수 카운트, null 포함
          - count(컬럼명): null 제외한 행 수 카운트
        - primary key: 기본키 지정
          - pk는 not null. unique한 값(테이블 내 중복 없음)
        - foreign key: 외래키 지정. 테이블 당 여러개 가능

    - ALTER: 테이블과 칼럼에 대해 이름 및 속성 변경, 추가/삭제 등 구조 수정을 위해 사용

      ```sql
      -- 	테이블			명령		대상
      ALTER TABLE MENU RENAME TO MENU;	--테이블명 변경
      RENAME TABLE MENU TO MENU	--테이블명 변경(다수 테이블명 동시에 변경 가능)
      ALTER TABLE MENU RENAME COLUMN phone TO 전화번호;	   --컬럼명 변경
      ALTER TABLE MENU MODIFY (이름 varchar(20) not null);	--칼럼 속성 변경
      ALTER TABLE MENU ADD (거주지역 varchar(10));	--칼럼 추가
      ALTER TABLE MENU DROP COLUMN 이름;			 --칼럼 삭제
      ALTER TABLE MENU ADD CONSTRAINT; 	--제약조건 추가
      ALTER TABLE MENU DROP CONSTRAINT;	--제약조건 삭제
      ```

    - RENAME: 이름 변경

    - DROP: 테이블 및 칼럼 삭제

      ```sql
      ALTER TABLE MENU DROP COLUMN 이름;	--칼럼 삭제
      DROP TABLE MENU;		--테이블 삭제
      ```

      - 테이블 삭제 유의사항
        - DROP TABLE MENU CASCADE CONSTRAINT;	
          - 해당 테이블의 데이터를 외래키로 참조한 제약사항도 모두 삭제
          - ORACLE에만 있는 조건. SQL SERVER에는 존재하지 않음
          - FK제약조건과 참조테이블 먼저 삭제하고, 해당 테이블을 삭제한다

    - TRUNCATE: 테이블 초기화

      - DROP vs. TRUNCATE

        ```sql
        DROP TABLE MENU;		--테이블 관련해서 모두 삭제. (구조와 데이터도)
        TRUNCATE TABLE MENU;	--테이블 데이터만 삭제되고 구조는 살아있다
        ```

        - DROP
          - 테이블 정의를 완전 삭제
          - 테이블이 사용했던 모든 저장공간을 Release됨
        - TRUNCATE
          - 테이블을 초기상태로 만듦(뼈대만 살렸다)
          - 테이블 최초 형성 시 사용했던 저장공간만 남기고 Release

  - DML: 정의된 데이터베이스에 레코드를 입력하거나, 수정, 삭제 및 조회하기 위한 명령어다.

    ```sql
    INSERT INTO MENU (NAME) VALUES ('연어스시');
    UPDATE MENU SET discount_rate = 10 (where name = '연어스시');
    DELETE FROM MENU (WHERE name='연어스시')
    
    UPDATE MENU SET 메뉴코드 =100 WHERE 메뉴명='연어스시'
    DELETE MENU
    INSERT INTO MENU (메뉴코드, 가격, 메뉴명) VALUES ('100', 1000, '연어스시')
    INSERT INTO MENU VALUES ('100', '연어스시', 300, 0)	--튜플
    ```

    - INSERT: 데이터 입력
      - 칼럼명 지정이 이뤄지지 않은 상태에서는 전체값이 들어가야함
      - not null 값인 메뉴명에 대한 insert가 이뤄지지 않을 경우 오류 발생
      
    - UPDATE: 데이터 수정
      
      - COL1 컬럼에 행이 3개가 있는데 UPDATE 테이블 SET COL1=50이라고 하면 모든 행의 값이 50으로 바뀐다
      
    - DELETE: 데이터 삭제
      - DELETE에서 FROM 생략 가능. DELETE MENU 가능
      - 숫자는 varchar2와 char에 입력 가능.
      - 삭제된 데이터에 대해 로그를 남길 수 있는 방법. DB에 반영되기 전까지 삭제된 데이터를 다시 되돌릴 수 있다
        -> 데이터는 삭제되지만 용량이 줄어들지 않는다.
      - 특정행을 삭제할 수 있다

    - SELECT: 조회

      - **SELECT** 조회대상(컬럼명 등) **FROM** 테이블명 **WHERE** 조건문 **GROUP BY** 집계기준컬럼명 **HAVING** grouping된 후 상태 기반의 조건문 **ORDER BY** 컬럼명

      - 예시

        INFO

        | 유저코드 | 성별 | 이름 |
        | -------- | ---- | ---- |
        | 1A       | F    | A    |
        | 2A       | M    | B    |
        | 3A       | M    | C    |
        | 4A       | F    | D    |
        | 5A       |      | E    |

        ```sql
        SELECT COUNT(*) FROM C_INFO      	   --5
        SELECT COUNT(성별) FROM C_INFO		  --4
        SELECT COUNT(DISTINCT 성별) FROM C_INFO --3
        ```
        - SELECT DISTINCT: 중복값 없이 가져오는 것. NULL도 단일 행으로 본다. 만약 DISTINCT가 두 컬럼에 대해 적용되었다면 컬럼의 조합에서 중복을 제거하고 조회한다

      - SELECT문 기본 구조 - 문자형 함수

        ```sql
        LOWER('SQL')			--'sql'
        UPPER('sql')			--'SQL'
        CONCAT('S'+'QL') = 'S'||'QL' = 'S'+'QL'	--'SQL'
        SUBSTR('SQL',2,2)		--'QL'
        LEN('S QL')				--4
        TRIM('AABBCCAA', 'A')	--'BBCC'
        TRIM(' AABBCCAA ',)		--'AABBCCAA'	지정된 문자 없으면 공백 제거
        LTRIM('AABBCCAA', 'A')	--'BBCCAA'
        LTRIM(' AABBCCAA ',)	--'AABBCCAA '
        RTRIM('AABBCCAA', 'A') 	--'AABBCC'
        RTRIM(' AABBCCAA ',)	--' AABBCCAA'
        
        SELECT TRIM(유저코드, 'A'), LOWER(이름) FROM INFO	
        --INFO 테이블에서 양쪽에서 A를 제거한 유저코드, 소문자로 나타낸 이름을 조회
        SELECT T1.* FROM table1 T1, table2 T2 WHERE UPPER(T1.col1) LIKE T2.col1
        /* T1(테이블1)의 col1을 대문자로 변환한 결과가 T2(테이블2)와 유사한 경우 둘을 접합시키고 T1에 있는 모든 것을 조회 */
        ```

        - LOWER(문자열): 영어 문자열 소문자로 변환
        - UPPER(문자열): 영어 문자열 대문자로 변환
        - CONCAT(문자열1, 문자열2): 문자열 1과 문자열2를 결합
        - SUBSTR(문자열,m,n): 문자열에서 <u>m번째 자리값부터 n개</u>를 자른다
        - LENGTH(문자열) = LEN(문자열): <u>공백을 포함</u>하여 문자열의 길이값
        - TRIM(문자열, 제거대상): 왼쪽과 오른쪽에서 지정된 문자를 삭제한다
          - LTRIM(문자열, 제거대상): 왼쪽에서 지정된 문자를 삭제한다
          - RTRIM(문자열, 제거대상): 오른쪽에서 지정된 문자를 삭제한다

      - SELECT문 기본 구조 - 숫자형 함수

        ```sql
        ROUND(25.3467, 2)	--25.35
        TRUNC(25.3467, 2)	--25.34
        CEIL(25.3427)		--26
        FLOOR(25.3427)		--25
        MOD(25, 7)			--4
        SIGN(25.3427)		--1
        ABS(25.3427)		--25.3427
        ```

        - ROUND(숫자, 소숫점 자릿수): 반올림
        - TRUNC(숫자, 소숫점 자릿수): 버림
        - CEIL(숫자): 크거나 같은 최대 정수 반환
        - FLOOR(숫자): 작거나 같은 최대 정수 반환
        - MOD(분자, 분모): 분자를 분모로 나눈 나머지 반환
        - SIGN(숫자): 숫자가 양수면 1, 0이면 0, 음수면 -1 반환
        - ABS(숫자): 절댓값

      - SELECT문 기본 구조 - 날짜형 함수

        ```sql
        SELECT SYSDATE FROM DUAL	--2022/05/23 11:45:23(datetime 형태)
        --DUAL은 오라클이 설치될 때 만들어지는 테이블. 산술, 날짜 처리 등을 하는 기본 임시 테이블
        EXTRACT(YEAR FROM sysdate)	--2022
        EXTRACT(YEAR FROM sysdate) TO_NUMBER(TO_CHAR(sysdate, 'YYYY')) --2022
        ```

        - SYSDATE: 쿼리를 돌리는 현재 날짜 & 시각 출력
        - EXTRACT(정보 FROM 날짜): 날짜형 데이터에서 원하는 값을 출력함
          - 정보: YEAR, MONTH, DAY, HOUR, MINUTE, SECOND

  - TCL: 트랜잭션을 제어하기 위한 언어 

    - COMMIT: 데이터에 대한 변화를 DB에 반영하기 위한 명령어
      - 영구적으로 반영이 됨 = COMMIT되어 DB에 들어감
    - ROLLBACK: 코드를 분할하기 위한 저장 포인트 지정
      - SAVEPOINT가 쓰여있지 않을 경우 가장 최신의 COMMIT 상태로 복원된다
    - SAVEPOINT: 트랜잭션이 시작되기 이전의 상태로 되돌리기 위한 언어. 
      최신 COMMIT이나 특수한 SAVEPOINT로 되돌릴 수 있는 명령어

    +. COMMIT과 ROLLBACK의 효과

    	1. 데이터 무결성을 보장할 수 있다
    	2. 영구적인 변경 전 데이터에 대한 변동사항을 확인할 수 있다
    	3. 논리적 연관성 있는 작업을 그룹화하여 처리할 수 있다

    +. 트랜잭션: 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위

    - 특징
      - 고립성: 트랜잭션이 **실행되는 동안** 다른 트랜잭션에 영향을 받아 잘못된 결과를 만들어선 안된다
      - 원자성: **all or nothing**. 트랜잭션에서 정의된 연산은 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않은 상태로 있어야 한다
      - 지속성: 트랜잭션이 성공적으로 완료되면 해당 트랜잭션이 갱신한 데이터베이스의 내용은 **영구적으로 저장**
      - 일관성: 트랜잭션 발생 전 데이터베이스 내용에 잘못된 점이 없다면 트랜잭션 **수행 후**에도 데이터베이스의 내용에 잘못이 있으면 안된다